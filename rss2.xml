<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Believe Be:leave</title>
    <link>http://mayuyu.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>それは凄い桜だったが、もう二度と咲くことは無いだろう。</description>
    <pubDate>Sun, 02 Dec 2018 12:18:07 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>de_obf Part1: Theory</title>
      <link>http://mayuyu.io/2018/12/01/de_obf_part1/</link>
      <guid>http://mayuyu.io/2018/12/01/de_obf_part1/</guid>
      <pubDate>Sat, 01 Dec 2018 11:52:54 GMT</pubDate>
      <description>
      
        &lt;p&gt;Continuing the tradition from 2017, the topic for my annual InfoSec related hackathon is code deobfuscation.&lt;br&gt;We will be focusing on x86_64 MachOs obfuscated by my 2017 christmas project only and ignore all multi-stage obfuscations to make this small toy project as trivial as possible. As there has been a ton of similar researches on solving such tasks with overkill weapons like symbolic execution and dynamic taint analysis (and because I’m extremely new to this field), I decided to take a purely static approach, as in we are not  attempting to do much more than a traditional static decompiler. Here are some theories I designed that should be hopefully more than enough for our task. It’s suggested for the the reader to have some LLVM background prior to reading through this article, however LLVM is rarely mentioned and the reader should be able to guess the meaning of LLVM related part without too much hassle.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Continuing the tradition from 2017, the topic for my annual InfoSec related hackathon is code deobfuscation.<br>We will be focusing on x86_64 MachOs obfuscated by my 2017 christmas project only and ignore all multi-stage obfuscations to make this small toy project as trivial as possible. As there has been a ton of similar researches on solving such tasks with overkill weapons like symbolic execution and dynamic taint analysis (and because I’m extremely new to this field), I decided to take a purely static approach, as in we are not  attempting to do much more than a traditional static decompiler. Here are some theories I designed that should be hopefully more than enough for our task. It’s suggested for the the reader to have some LLVM background prior to reading through this article, however LLVM is rarely mentioned and the reader should be able to guess the meaning of LLVM related part without too much hassle.</p><a id="more"></a><h1 id="Passes"><a href="#Passes" class="headerlink" title="Passes"></a>Passes</h1><h2 id="IndirectBranch"><a href="#IndirectBranch" class="headerlink" title="IndirectBranch"></a>IndirectBranch</h2><p>The open-source version is pretty trivial with regards to both its implementation and the solution to defeat it. To summerize, for each function, a table of all the BasicBlocks in this function is created and each unconditional <code>br</code> instruction is transformed into a sequence of <code>getelementptr</code>, <code>load</code> and <code>br</code> instructions. For each conditional <code>br</code> instruction, a local branching table is created and similar process is carried out. Since modern compilers and decompilers are really good at optimizing the first scenario, it’s as easy as statically finding such instruction patterns and patch them accordingly to deobfuscate such binaries. For the conditional part, things are a little bit trickier. However since the type signature of a conditional ranch instruction is actually <code>br i1 BasicBlock True, BasicBlock False</code>, such assembly binary patterns can only have the formula of  <code>(branch table address)+(0 or 1)*sizeof(address)</code>. Since all elements in this formula is statically calculatable by doing some disassembling, IndirectBranch is overall the easist obfucation to defeat.</p><h2 id="BogusControlFlow"><a href="#BogusControlFlow" class="headerlink" title="BogusControlFlow"></a>BogusControlFlow</h2><p>For this one, the general idea is to generate pseudo conditional branches backed by a compile time evaluated mathematical expression, which always evaluates to one side so we can insert junk instructions and do all kinds of crazy stuff on the other side.<br>In detail, the constants in this obfuscation are added as GlobalVariable to bypass LLVM’s compile time optimizations, because otherwise we might see some really awkward cases like this one found in <a href="https://www.panic.com/transmit/" target="_blank" rel="noopener">Transmit App</a></p><p><img src="oops.png" alt=""></p><p>So in order to defeat such obfuscations, the core idea is to find conditional jumps and for each of these instructions, we backtrace the control flow and do some dataflow analysis to find out how the final condition is evaluated. The final DFA should match the pattern that all involved values are loaded from a GlobalVariable that has only one cross reference (Our BasicBlock). From this point on we can:  </p><ul><li>Simulate related instruction by hand</li><li>Use a decent engine like <a href="https://www.unicorn-engine.org" target="_blank" rel="noopener">Unicorn Engine</a></li><li>Runtime Analysis (Cheating!) like generate LLDB scripts that break on those intructions and dump out the condition registers, they should have the same value in each run.</li></ul><h2 id="Flattening"><a href="#Flattening" class="headerlink" title="Flattening"></a>Flattening</h2><p>This one is actually the hardest, however do note that in summary, all flattening does is create a temporary value on stack and a switch instruction that jumps to different BasicBlocks depending on the temporary value, the old BasicBlocks are modified so that after normal execution, they update the temporary value to indicate the next BasicBlock they want to execute and jump back to the switch instrucion. In order to deobfuscate this, we will need to find the BasicBlock containing the Switch Instruction, known as the dispatcher, and the bottom entirely useless block which does absolutely nothing except jumping back to the dispatcher. The second one is easy to find, from graph theory’s perspective, this BasicBlock has a large number of incoming edges and only one outgoing edge. The first one is usually the third BasicBlock we encounter into the function and if for some reason that didn’t work, switch table is still your friend : )</p><p>Now with the dispatcher sorted out, we can now locate the temporary value’s address on stack by analyzing the dispatcher and its parent block, from there we can check for instructions that write to the temporary value, which in turn allows us to recover the original CFG by associating the values written with the original CFG.</p><h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>However in order to implement these theories, we’ll need to first identify the BasicBlocks in the program, or in otherwords we are essentially rewriting our own disassembler, while <a href="http://www.capstone-engine.org" target="_blank" rel="noopener">Capstone Engine</a> is dope enough and can handle more than a dozen instruction sets, Capstone at its core is nothing more than a linear disassembler. For modern binaries and disassemblers, we need a more advanced algorithm called Recursive Descent Disassembly, which is a lot more troublesome than it might sounds. So our first task as this point is to either craft our own disassembler or find another engine for this. The actual implementation is left to discuss in Part II that will hopefully come before Christmas Eve.</p>]]></content:encoded>
      
      <comments>http://mayuyu.io/2018/12/01/de_obf_part1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Cross-Platform VMProtect with LLVM</title>
      <link>http://mayuyu.io/2018/08/08/Cross-Platform-VMProtect-with-LLVM/</link>
      <guid>http://mayuyu.io/2018/08/08/Cross-Platform-VMProtect-with-LLVM/</guid>
      <pubDate>Wed, 08 Aug 2018 15:24:45 GMT</pubDate>
      <description>
      
        &lt;p&gt;I finally had enough fun with building LLVM Transform Obfuscation Passes and decided to build a VMProtect-Like obfuscation mechanism.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>I finally had enough fun with building LLVM Transform Obfuscation Passes and decided to build a VMProtect-Like obfuscation mechanism.</p><a id="more"></a><p>Below is the emulated CPU’s control flow graph. Extra protection disabled, otherwise you won’t even see this graph.<br><img src="VMP.png" alt=""></p><h2 id="Current-Implementations"><a href="#Current-Implementations" class="headerlink" title="Current Implementations"></a>Current Implementations</h2><h3 id="Assembly-Interpreter"><a href="#Assembly-Interpreter" class="headerlink" title="Assembly Interpreter"></a>Assembly Interpreter</h3><ul><li>Mostly used design pattern</li><li>Takes a large amount of time to add support for a new platform</li><li>Not Fast Enough</li><li>Hard to maintain/debug</li></ul><h3 id="LLVM-IR-Interpreter"><a href="#LLVM-IR-Interpreter" class="headerlink" title="LLVM IR Interpreter"></a>LLVM IR Interpreter</h3><ul><li>Similar to Assembly Interpreter, expect more trouble to solve. For example using reg2mem to resolve PhiNodes</li><li>Bridging with native code. Global Variable/Local Memory Address mapping</li><li>var-arg support</li><li>Emulating stack?</li></ul><h3 id="High-Level-Language-Interpreter"><a href="#High-Level-Language-Interpreter" class="headerlink" title="High-Level Language Interpreter"></a>High-Level Language Interpreter</h3><ul><li>Not safe enough(Dump out string and it’s over.)</li><li>JIT implementation requires a full compile chain available at runtime.</li><li>Raw Interpreter Implementation needs to handle structure coercion in order to properly support foreign function calling<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="External Reading: [DragonFFI: FFI/JIT for the C language using Clang/LLVM](http://blog.llvm.org/2018/03/dragonffi-ffijit-for-c-language-using.html)">[1]</span></a></sup></li></ul><h2 id="Hikari’s-implementation"><a href="#Hikari’s-implementation" class="headerlink" title="Hikari’s implementation"></a>Hikari’s implementation</h2><p>In order to achieve cross platform with minimum effort, Hikari’s VM Protection emulates a specialized CPU with full fetch-decode-execute cycle.</p><h3 id="Supporting-LLVM-Instructions"><a href="#Supporting-LLVM-Instructions" class="headerlink" title="Supporting LLVM Instructions"></a>Supporting LLVM Instructions</h3><ul><li>Cast Instructions are essentially no-op</li><li>CallInsts are handled by using LLVM to generate proper assembly CallSites</li><li>BinaryOperators are obviously easy to handle</li><li>Invoke Instructions are lowered to CallInsts (Essentially unsupported atm)</li><li>Load/Stores are properly bitcasted</li><li>Everything else is left as-is</li></ul><p>The arguments are passed as pointers and each op’s handling block is responsible for specializing itself to handle each variation of the arguments.</p><h3 id="Finding-Candidate-Instructions"><a href="#Finding-Candidate-Instructions" class="headerlink" title="Finding Candidate Instructions"></a>Finding Candidate Instructions</h3><p>Since our VM implementation is pretty dumb and doesn’t support all the instructions(yet), we need to find instruction sequences to patch and replace. This algorithm is pretty straightforward at the moment. Do note, however, that we need to run various lowering passes to make sure:  </p><ul><li>PhiNodes are properly lowered</li><li>Intrinsics are either stripped out or lowered into platform specific library calls</li><li>ConstantExprs are properly resolved</li><li>etc…</li></ul><p>The actual source code won’t be open-source but you should be able to craft yourself one after reading this.</p><p>Zhang</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">External Reading: <a href="http://blog.llvm.org/2018/03/dragonffi-ffijit-for-c-language-using.html" target="_blank" rel="noopener">DragonFFI: FFI/JIT for the C language using Clang/LLVM</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>http://mayuyu.io/2018/08/08/Cross-Platform-VMProtect-with-LLVM/#disqus_thread</comments>
    </item>
    
    <item>
      <title>PhiNode in LLVM</title>
      <link>http://mayuyu.io/2018/06/04/PhiNode-in-LLVM/</link>
      <guid>http://mayuyu.io/2018/06/04/PhiNode-in-LLVM/</guid>
      <pubDate>Mon, 04 Jun 2018 20:18:23 GMT</pubDate>
      <description>
      
        &lt;p&gt;PhiNode is one of the most confusing concepts in compiler intermediate languages. This post attempts to introduces its concept and various fun aspects of it.&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>PhiNode is one of the most confusing concepts in compiler intermediate languages. This post attempts to introduces its concept and various fun aspects of it.<br><a id="more"></a></p><h1 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h1><p>SSA form, which stands for <code>Static Single Assignment</code>. Basically it means each variable is assigned exactly once. This is related to what we’ll be talking about today, as we will shortly see.<br>PhiNode refers to a special Instruction/Value/Node in compiler IR that changes its value depending on the control flow, which is usually used when the diverged control flow of a program merges back together.</p><h1 id="Main-Dish"><a href="#Main-Dish" class="headerlink" title="Main Dish"></a>Main Dish</h1><p>Now we can craft a simple function to demostrate PhiNode:   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int foooooo(int bar)&#123;</span><br><span class="line">  int i=0;</span><br><span class="line">  if(bar%2==0)&#123;</span><br><span class="line">    i=1; //BasicBlock 1</span><br><span class="line">  &#125;</span><br><span class="line">  else&#123;</span><br><span class="line">    i=2; //BasicBlock 2</span><br><span class="line">  &#125;</span><br><span class="line">  return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It’s pretty obvious to see that in this case the variable <code>i</code> is assigned twice (<code>i=1 and i=2</code>), which breaks the definition of SSA (assigned <strong>exactly once</strong>). (However real world compilers won’t generate PhiNode for this piece of code because here <code>i</code> is allocated on stack as a temporary variables and BB1&amp;BB2 are simply storing into it.)<br>That’s when PhiNode kicks in. For example, we could rewrite <code>foooooo</code> in the following form:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(bar%2==0)&#123;</span><br><span class="line">   //BasicBlock1</span><br><span class="line"> &#125;</span><br><span class="line"> else&#123;</span><br><span class="line">   //BasicBlock2</span><br><span class="line"> &#125;</span><br><span class="line"> int i=Phi([BasicBlock1,1],[BasicBlock2,2])</span><br><span class="line"> return i;</span><br></pre></td></tr></table></figure><p>However, since no real world processors supports PhiNode, the compiler must generates code without PhiNode semantics, and this is where PhiNode Resolving (otherwise known as SSA Destruction) Process kicks in.<br>At LLVM IR level, this is achieved by using <a href="https://github.com/llvm-mirror/llvm/blob/master/lib/Transforms/Utils/DemoteRegToStack.cpp#L109" target="_blank" rel="noopener">DemotePHIToStack</a> or its wrapper Pass <a href="https://github.com/llvm-mirror/llvm/blob/master/lib/Transforms/Scalar/Reg2Mem.cpp" target="_blank" rel="noopener">reg2mem</a>. These two passes are both doing one similar thing, as we will shortly see. One thing to keep in mind is that SSA form IR could be easily imagined as running on a virtual CPU with infinite registers and each of the SSA values corresponds to one of the virtual registers.</p><h1 id="Rev-s-olver"><a href="#Rev-s-olver" class="headerlink" title="Rev(s)olver"></a>Rev(s)olver</h1><p>As <code>DemotePHIToStack</code> and <code>reg2mem</code> ‘s name suggests, they convert the SSA values into a memory location. But what does that mean? Essentially, our simple example could now be represented in the following C-style pseudo-code:   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int* i=malloc(sizeof(int));</span><br><span class="line">if(bar%2==0)&#123;</span><br><span class="line">Store Value 1 to the memory location pointed to by i</span><br><span class="line"> &#125;</span><br><span class="line"> else&#123;</span><br><span class="line">   Store Value 2 to the memory location pointed to by i</span><br><span class="line"> &#125;</span><br><span class="line"> int j=load from the address pointed by i</span><br><span class="line"> return j;</span><br></pre></td></tr></table></figure><p>This is essentially achieved by inserting <code>alloca</code>, <code>store</code> and <code>load</code> LLVM Assembly instructions at places.</p><p>Other possible places for PhiResolving includes the backend, or to be precise, the Register Allocation stage, while SSA values are assigned the same register if possible, or insert move instructions to the end of affected BasicBlock if possible.</p><p>To revert this process, there are <a href="https://github.com/llvm-mirror/llvm/blob/master/lib/Transforms/Utils/PromoteMemoryToRegister.cpp" target="_blank" rel="noopener">PromoteMemoryToRegister</a> or its wrapper class <a href="https://github.com/llvm-mirror/llvm/blob/master/lib/Transforms/Utils/Mem2Reg.cpp" target="_blank" rel="noopener">mem2reg</a> for this.</p><h1 id="External-Reading"><a href="#External-Reading" class="headerlink" title="External Reading"></a>External Reading</h1><ul><li><a href="https://en.wikipedia.org/wiki/Static_single_assignment_form" target="_blank" rel="noopener">Static single assignment form</a></li><li><a href="http://ssabook.gforge.inria.fr/latest/book.pdf" target="_blank" rel="noopener">Static Single Assignment Book</a></li></ul>]]></content:encoded>
      
      <comments>http://mayuyu.io/2018/06/04/PhiNode-in-LLVM/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Porting Hikari to Swift/Clang and Build for Production</title>
      <link>http://mayuyu.io/2018/02/13/Porting-Hikari-to-Swift-Clang/</link>
      <guid>http://mayuyu.io/2018/02/13/Porting-Hikari-to-Swift-Clang/</guid>
      <pubDate>Tue, 13 Feb 2018 06:03:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;Since Apple’s Development Tools contains a bunch of modifications that will probably never see its day in LLVM upstream and Swift contains the latest open-source Apple fork of LLVM at the moment. It’s probably wise to port Hikari to Swift instead of using the upstream.&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Since Apple’s Development Tools contains a bunch of modifications that will probably never see its day in LLVM upstream and Swift contains the latest open-source Apple fork of LLVM at the moment. It’s probably wise to port Hikari to Swift instead of using the upstream.<br><a id="more"></a></p><h1 id="Obtaining-the-source-code"><a href="#Obtaining-the-source-code" class="headerlink" title="Obtaining the source code"></a>Obtaining the source code</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir swiftsrc \</span><br><span class="line">&amp;&amp; cd swiftsrc \</span><br><span class="line">&amp;&amp; git clone https://github.com/apple/swift.git \</span><br><span class="line">&amp;&amp; ./swift/utils/update-checkout --clone</span><br></pre></td></tr></table></figure><h1 id="Porting-the-Hikari-Core"><a href="#Porting-the-Hikari-Core" class="headerlink" title="Porting the Hikari Core"></a>Porting the Hikari Core</h1><p>Hikari’s core is located at <code>lib/Transforms/Obfuscation</code>, plus headers at <code>include/llvm/Transforms/Obfuscation/</code>.<br><code>HikariObfuscator/Mirai</code> is the modified LLVM Core. So we first need to locate the Swift LLVM Core we just cloned, which is <code>swiftsrc/llvm</code>.  </p><ul><li>Copy <code>Hikari/lib/Transforms/Obfuscation</code> to <code>swiftsrc/llvm/lib/Transforms/Obfuscation</code></li><li>Copy <code>Hikari/include/llvm/Transforms/Obfuscation</code> to <code>swiftsrc/llvm/include/llvm/Transforms/Obfuscation</code></li><li>Edit <code>swiftsrc/llvm/lib/Transforms/LLVMBuild.txt</code>, add <code>Obfuscation</code> at the end of <code>subdirectories</code></li><li>Edit <code>swiftsrc/llvm/lib/Transforms/CMakeLists.txt</code>, add <code>add_subdirectory(Obfuscation)</code> at the end</li><li>Edit <code>swiftsrc/llvm/lib/Transforms/IPO/LLVMBuild.txt</code>, add <code>Obfuscation</code> at the end of <code>required_libraries</code></li><li>Edit <code>swiftsrc/llvm/lib/IPO/PassManagerBuilder.cpp</code>, add <code>#include &quot;llvm/Transforms/Obfuscation/Obfuscation.h&quot;</code> at the end of those <code>#include</code> statements, add <code>MPM.add(createObfuscationPass());</code> at the beginning of <code>void PassManagerBuilder::populateModulePassManager</code></li><li>Edit <code>swiftsrc/llvm/include/llvm/InitializePasses.h</code>, add the following right after the last <code>void initializeXXXX</code> definition:  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void initializeStringEncryptionPass(PassRegistry &amp;);</span><br><span class="line">void initializeFunctionCallObfuscatePass(PassRegistry &amp;);</span><br><span class="line">void initializeAntiDebuggingPass(PassRegistry &amp;);</span><br><span class="line">void initializeAntiClassDumpPass(PassRegistry &amp;);</span><br><span class="line">void initializeBogusControlFlowPass(PassRegistry &amp;);</span><br><span class="line">void initializeFlatteningPass(PassRegistry &amp;);</span><br><span class="line">void initializeSplitBasicBlockPass(PassRegistry &amp;);</span><br><span class="line">void initializeSubstitutionPass(PassRegistry &amp;);</span><br><span class="line">void initializeAntiDebuggingPass(PassRegistry &amp;);</span><br><span class="line">void initializeAntiHookPass(PassRegistry &amp;);</span><br><span class="line">void initializeIndirectBranchPass(PassRegistry &amp;);</span><br><span class="line">void initializeObfuscationPass(PassRegistry &amp;);</span><br></pre></td></tr></table></figure><ul><li>Edit <code>swiftsrc/llvm/include/llvm/LinkAllPasses.h</code>, add <code>#include &quot;llvm/Transforms/Obfuscation/Obfuscation.h&quot;</code> at the end of those <code>#include</code> statements,then add the following right after the last <code>(void) llvm::createXXXXX</code> definition:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(void) llvm::createStringEncryptionPass();</span><br><span class="line">(void) llvm::createFunctionCallObfuscatePass();</span><br><span class="line">(void) llvm::createAntiClassDumpPass();</span><br><span class="line">(void) llvm::createBogusControlFlowPass();</span><br><span class="line">(void) llvm::createFlatteningPass();</span><br><span class="line">(void) llvm::createSplitBasicBlockPass();</span><br><span class="line">(void) llvm::createSubstitutionPass();</span><br><span class="line">(void) llvm::createAntiDebuggingPass();</span><br><span class="line">(void) llvm::createAntiHookPass();</span><br><span class="line">(void) llvm::createIndirectBranchPass();</span><br><span class="line">(void) llvm::createObfuscationPass();</span><br></pre></td></tr></table></figure><h1 id="Building"><a href="#Building" class="headerlink" title="Building"></a>Building</h1><h2 id="Effortless-Building"><a href="#Effortless-Building" class="headerlink" title="Effortless Building"></a>Effortless Building</h2><p>  Apple provided <code>swiftsrc/swift/utils/build-toolchain</code></p><h2 id="Crafted-Build-Options"><a href="#Crafted-Build-Options" class="headerlink" title="Crafted Build Options"></a>Crafted Build Options</h2><p><code>utils/build-toolchain</code> provides a dumb wrapper around the core build script and doesn’t provide fine tuning. We could it a little to provide new Toolchain name and stuff. I personally replaced the <code>./utils/build-script</code> command to something like this:   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./utils/build-script $&#123;DRY_RUN&#125; --preset-file=&quot;utils/HikariSwift&quot; --preset=&quot;Hikari&quot;\</span><br><span class="line">        install_destdir=&quot;$&#123;SWIFT_INSTALL_DIR&#125;&quot; \</span><br><span class="line">        installable_package=&quot;$&#123;SWIFT_INSTALLABLE_PACKAGE&#125;&quot; \</span><br><span class="line">        install_toolchain_dir=&quot;$&#123;SWIFT_TOOLCHAIN_DIR&#125;&quot; \</span><br><span class="line">        install_symroot=&quot;$&#123;SWIFT_INSTALL_SYMROOT&#125;&quot; \</span><br><span class="line">        symbols_package=&quot;$&#123;SYMBOLS_PACKAGE&#125;&quot; \</span><br></pre></td></tr></table></figure><p>Alone with a hand-crafted preset,stored at <code>utils/HikariSwift</code> :  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">[preset: Hikari]</span><br><span class="line"></span><br><span class="line">dash-dash</span><br><span class="line">no-assertions</span><br><span class="line">ios</span><br><span class="line">tvos</span><br><span class="line">watchos</span><br><span class="line"></span><br><span class="line">lldb</span><br><span class="line">llbuild</span><br><span class="line">swiftpm</span><br><span class="line">playgroundsupport</span><br><span class="line">release</span><br><span class="line">compiler-vendor=none</span><br><span class="line">dash-dash</span><br><span class="line">lldb-no-debugserver</span><br><span class="line">lldb-use-system-debugserver</span><br><span class="line">extra-cmake-options=-DCMAKE_BUILD_TYPE=MinSizeRel</span><br><span class="line">verbose-build</span><br><span class="line">build-ninja</span><br><span class="line">build-swift-static-stdlib</span><br><span class="line">build-swift-static-sdk-overlay</span><br><span class="line">build-swift-stdlib-unittest-extra</span><br><span class="line">playgroundsupport-build-type=Release</span><br><span class="line"></span><br><span class="line">install-swift</span><br><span class="line">install-lldb</span><br><span class="line">install-llbuild</span><br><span class="line">install-swiftpm</span><br><span class="line">install-playgroundsupport</span><br><span class="line"></span><br><span class="line">install-destdir=%(install_destdir)s</span><br><span class="line"></span><br><span class="line">darwin-install-extract-symbols</span><br><span class="line"></span><br><span class="line"># Path where debug symbols will be installed.</span><br><span class="line">install-symroot=%(install_symroot)s</span><br><span class="line"></span><br><span class="line"># Path where the compiler, the runtime and the standard libraries will be</span><br><span class="line"># installed.</span><br><span class="line">install-prefix=%(install_toolchain_dir)s/usr</span><br><span class="line">skip-test-swift</span><br><span class="line">skip-test-swiftpm</span><br><span class="line">skip-test-llbuild</span><br><span class="line">skip-test-lldb</span><br><span class="line">skip-test-cmark</span><br><span class="line">skip-test-playgroundsupport</span><br><span class="line">swift-install-components=compiler;clang-builtin-headers;stdlib;swift-syntax;sdk-overlay;license;sourcekit-xpc-service;swift-remote-mirror;swift-remote-mirror-headers</span><br><span class="line">llvm-install-components=libclang;libclang-headers</span><br><span class="line"></span><br><span class="line"># Path to the .tar.gz package we would create.</span><br><span class="line">installable-package=%(installable_package)s</span><br><span class="line"></span><br><span class="line"># Path to the .tar.gz symbols package</span><br><span class="line">symbols-package=%(symbols_package)s</span><br><span class="line"></span><br><span class="line"># Info.plist</span><br><span class="line">darwin-toolchain-bundle-identifier=&quot;com.naville.hikariswift&quot;</span><br><span class="line">darwin-toolchain-display-name=&quot;HikariSwift&quot;</span><br><span class="line">darwin-toolchain-display-name-short=&quot;HikariSwift&quot;</span><br><span class="line">darwin-toolchain-name=&quot;HikariSwift&quot;</span><br><span class="line">darwin-toolchain-version=&quot;1.0.0&quot;</span><br><span class="line">darwin-toolchain-alias=&quot;Local&quot;</span><br></pre></td></tr></table></figure><h1 id="Miscellaneous-Notes"><a href="#Miscellaneous-Notes" class="headerlink" title="Miscellaneous Notes"></a>Miscellaneous Notes</h1><ul><li>AAPL didn’t ship LLVM’s libcxx and libcxxabi. You might want to setup those yourself</li><li>Hikari is pretty much untested on Swift projects</li><li>Swift frontend uses a slightly different argument to pass LLVM flags</li></ul>]]></content:encoded>
      
      <comments>http://mayuyu.io/2018/02/13/Porting-Hikari-to-Swift-Clang/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Bug in Obfuscator-LLVM&#39;s Bogus Control Flow</title>
      <link>http://mayuyu.io/2017/12/27/BogusControlFlowBug/</link>
      <guid>http://mayuyu.io/2017/12/27/BogusControlFlowBug/</guid>
      <pubDate>Wed, 27 Dec 2017 13:36:33 GMT</pubDate>
      <description>
      
        &lt;p&gt;@Ouroburos sent me a &lt;a href=&quot;https://gist.github.com/Naville/37c61f653be529faceeb875554790c10&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IR&lt;/a&gt; which crashes Obfuscator-LLVM. So the investigation begin.&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>@Ouroburos sent me a <a href="https://gist.github.com/Naville/37c61f653be529faceeb875554790c10" target="_blank" rel="noopener">IR</a> which crashes Obfuscator-LLVM. So the investigation begin.<br><a id="more"></a><br>Below is a generated Control-Flow-Graph for the affected function.<br><img src="OriginalCFG.png" alt=""></p><p>However running bcf on this IR using <code>bin/opt -boguscf -bcf_prob=100</code> won’t pass IRVerifier, yielding the following message:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">The unwind destination does not have an exception handling instruction!</span><br><span class="line">  %10 = invoke %1* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to %1* (i8*, i8*)*)(i8* %7, i8* %9) #3</span><br><span class="line">          to label %11 unwind label %16</span><br><span class="line">Block containing LandingPadInst must be jumped to only by the unwind edge of an invoke.</span><br><span class="line">  %25 = landingpad &#123; i8*, i32 &#125;</span><br><span class="line">          cleanup</span><br><span class="line">Block containing LandingPadInst must be jumped to only by the unwind edge of an invoke.</span><br><span class="line">  %34 = landingpad &#123; i8*, i32 &#125;</span><br><span class="line">          cleanup</span><br><span class="line">LLVM ERROR: Broken function found, compilation aborted!</span><br></pre></td></tr></table></figure><p>Now that if you have enough knowledge of LLVM you will surely recognize this error as a InvokeInst going wild and jumping to illegal destination block. First, let’s bootup opt again and dump the CFG of the obfuscated IR, in order to do that we need to disable IR verifier first by using <code>-disable-verify</code>. The full command would be:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/opt -boguscf -bcf_prob=100 -S original.ll -disable-verify -o Obfuscated.ll  </span><br><span class="line">opt -dot-cfg Obfuscated.ll -disable-verify  </span><br><span class="line">dot -Tpng callgraph.dot -o cfg.png</span><br></pre></td></tr></table></figure><p>Yielding the following image.I did the annotation part for you : )  </p><p><img src="ObfuscatedCFG.png" alt="">   </p><p>Let’s explain this CFG a little bit more.Among other things, the root cause of the issue is the basicblock marked as <code>originalBBpart2</code>, which I’ve circled out with blue. If you remember our CFG for the un-obfuscated version, this block is the terminator of the first BB that got seperated out.Below is the code responsible for this extracted from Obfuscator-LLVM <code>78e056391160dab834682f7aaabe3a7a2afadcf6</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Split at this point (we only want the terminator in the second part)</span></span><br><span class="line">Twine * var5 = <span class="keyword">new</span> Twine(<span class="string">"originalBBpart2"</span>);</span><br><span class="line">BasicBlock * originalBBpart2 = originalBB-&gt;splitBasicBlock(--i , *var5);</span><br><span class="line">DEBUG_WITH_TYPE(<span class="string">"gen"</span>, errs() &lt;&lt; <span class="string">"bcf: Terminator part of the original basic block"</span>&lt;&lt; <span class="string">" is isolated\n"</span>);</span><br><span class="line"><span class="comment">// the first part go either on the return statement or on the begining</span></span><br><span class="line"><span class="comment">// of the altered block.. So we erase the terminator created when splitting.</span></span><br><span class="line">originalBB-&gt;getTerminator()-&gt;eraseFromParent();</span><br><span class="line"><span class="comment">// We add at the end a new always true condition</span></span><br><span class="line">Twine * var6 = <span class="keyword">new</span> Twine(<span class="string">"condition2"</span>);</span><br><span class="line">FCmpInst * condition2 = <span class="keyword">new</span> FCmpInst(*originalBB, CmpInst::FCMP_TRUE , LHS, RHS, *var6);</span><br><span class="line">BranchInst::Create(originalBBpart2, alteredBB, (Value *)condition2, originalBB);</span><br><span class="line">DEBUG_WITH_TYPE(<span class="string">"gen"</span>, errs() &lt;&lt; <span class="string">"bcf: Terminator original basic block: ok\n"</span>);</span><br><span class="line">DEBUG_WITH_TYPE(<span class="string">"gen"</span>, errs() &lt;&lt; <span class="string">"bcf: End of addBogusFlow().\n"</span>);</span><br></pre></td></tr></table></figure><p>Initially, this piece of code does seem to be correct. However, in order to loop though all BasicBlocks,the author used a <code>set&lt;BasicBlock*&gt;</code> in <code>void bogus(Function &amp;F)</code> following codes that insert all BBs from this function into the set. That’s how things went horribly wrong.<br>At later stage in the obfuscation, BasicBlock <code>%16</code> also got obfuscated into <code>%48</code>. Remember the BCF uses <code>BasicBlock::getFirstNonPHIOrDbgOrLifetime()</code> to locate the split point. And that, unfortunately, means our poor <code>LandingPad</code> also got splited to <code>originalBB6</code>.<br>Now <code>%26</code> ‘s terminating <code>InvokeInst</code> is using a BB that doesn’t have LandingPad. And the original LandingPad BasicBlock is now referenced by an unconditional BranchInst (aka the one after <code>%56</code>), this newly generated IR will surely fail to pass IRVerifier and thus crash the whole compiling process.</p><h1 id="Potential-fix"><a href="#Potential-fix" class="headerlink" title="Potential fix"></a>Potential fix</h1><p>The easist solution would be inserting codes checking if the BB is a landing pad before obfuscating. However I do feel like constant based branching condition is far from effective so here I purpose a new solution that generates random mathematical expressions as LHS and use <code>tinyexpr</code> to evaluate the RHS</p>]]></content:encoded>
      
      <comments>http://mayuyu.io/2017/12/27/BogusControlFlowBug/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Bug in StringEncryption Pass Armariris</title>
      <link>http://mayuyu.io/2017/12/26/StringEncryption/</link>
      <guid>http://mayuyu.io/2017/12/26/StringEncryption/</guid>
      <pubDate>Tue, 26 Dec 2017 15:21:12 GMT</pubDate>
      <description>
      
        &lt;p&gt;I’m preparing a new StringEncryption pass for Hikari, aim to fix various drawbacks from previous implementations.&lt;br&gt;The most famous one among those implementations would be &lt;a href=&quot;https://github.com/GoSSIP-SJTU/Armariris/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GoSSIP-SJTU/Armariris&lt;/a&gt;&lt;br&gt;You can read the pass’s full source &lt;a href=&quot;https://github.com/GoSSIP-SJTU/Armariris/blob/master/lib/Transforms/Obfuscation/StringObfuscation.cpp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HERE&lt;/a&gt;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>I’m preparing a new StringEncryption pass for Hikari, aim to fix various drawbacks from previous implementations.<br>The most famous one among those implementations would be <a href="https://github.com/GoSSIP-SJTU/Armariris/" target="_blank" rel="noopener">GoSSIP-SJTU/Armariris</a><br>You can read the pass’s full source <a href="https://github.com/GoSSIP-SJTU/Armariris/blob/master/lib/Transforms/Obfuscation/StringObfuscation.cpp" target="_blank" rel="noopener">HERE</a><br><a id="more"></a></p><h1 id="Drawbacks"><a href="#Drawbacks" class="headerlink" title="Drawbacks"></a>Drawbacks</h1><ul><li><p><code>Armariris</code> uses one single uint8_t as the encryption key across the full <a href="http://llvm.org/doxygen/classllvm_1_1ConstantAggregate.html" target="_blank" rel="noopener">ConstantAggregate</a> , <del>this is trival to bypass due to there are maximum 256 possible values for an <code>uint8_t</code>, even brute force is a feasible option. Plus extracting a XOR instruction from assemblies shouldn’t be too hard.</del><br>  We know that:</p><ul><li>Last character of the unencrypted c string is 0x00</li><li>We can extract the last character of the encrypted string.</li><li>We know one single key is used for all characters</li><li><p>We know the “encryption” is XOR.</p><p>Which means? : )</p></li></ul></li><li><p><code>Armariris</code> inject its global decryptor at <code>llvm.global_ctors</code>, for the C/ObjC/C++ guys reading this, this is equivalent to <code>__attribute__((constructor))</code>.(LLVM also has a global destructor,which is <code>llvm.global_dtors</code>, but that’s not the topic of this post). This makes it trival to <code>dump</code> decrypted strings at main executable’s entrypoint, where the system loader(<code>dyld</code> on Darwin) has finished calling ctors and thus decrypting our string GVs</p></li><li><p><code>Armariris</code> is not handling ObjC Strings correctly.Below is GV filtering code extracted from <code>Armariris</code>:  </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string section(gv-&gt;getSection());</span><br><span class="line">if (gv-&gt;isConstant() &amp;&amp; gv-&gt;hasInitializer() &amp;&amp;   </span><br><span class="line">isa&lt;ConstantDataSequential&gt;(gv-&gt;getInitializer())  </span><br><span class="line">&amp;&amp; section != &quot;llvm.metadata&quot; &amp;&amp;  </span><br><span class="line">section.find(&quot;__objc_methname&quot;) == std::string::npos) &#123;</span><br></pre></td></tr></table></figure><p>This piece of code did filter out LLVM Metadata usage,Non-CDS usage and GVs that are stored in <code>__objc_methname</code>.<br>However, consider the following code:  </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">foo</span>:<span class="title">NSObject</span>  </span></span><br><span class="line">+(<span class="keyword">void</span>)foo;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">foo</span>  </span></span><br><span class="line">+(<span class="keyword">void</span>)foo&#123;  </span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"FOOOO"</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>Which yields the following LLVM IR(Unrelated part stripped out):  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@.str = private unnamed_addr constant [6 x i8] c&quot;FOOOO\00&quot;, section &quot;__TEXT,__cstring,cstring_literals&quot;, align 1</span><br><span class="line">@_unnamed_cfstring_ = private global %struct.__NSConstantString_tag &#123; i32* getelementptr inbounds ([0 x i32], [0 x i32]* @__CFConstantStringClassReference, i32 0, i32 0), i32 1992, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i32 0, i32 0), i64 5 &#125;, section &quot;__DATA,__cfstring&quot;, align 8  </span><br><span class="line">@&quot;OBJC_METACLASS_$_NSObject&quot; = external global %struct._class_t</span><br><span class="line">@OBJC_CLASS_NAME_ = private unnamed_addr constant [4 x i8] c&quot;foo\00&quot;, section &quot;__TEXT,__objc_classname,cstring_literals&quot;, align 1  </span><br><span class="line">@OBJC_METH_VAR_NAME_ = private unnamed_addr constant [4 x i8] c&quot;foo\00&quot;, section &quot;__TEXT,__objc_methname,cstring_literals&quot;, align 1  </span><br><span class="line">@OBJC_METH_VAR_TYPE_ = private unnamed_addr constant [8 x i8] c&quot;v16@0:8\00&quot;, section &quot;__TEXT,__objc_methtype,cstring_literals&quot;, align 1  </span><br><span class="line">@&quot;\01l_OBJC_$_CLASS_METHODS_foo&quot; = private global &#123; i32, i32, [1 x %struct._objc_method] &#125; &#123; i32 24, i32 1, [1 x %struct._objc_method] [%struct._objc_method &#123; i8* getelementptr inbounds ([4 x i8], [4 x i8]* @OBJC_METH_VAR_NAME_, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @OBJC_METH_VAR_TYPE_, i32 0, i32 0), i8* bitcast (void (i8*, i8*)* @&quot;\01+[foo foo]&quot; to i8*) &#125;] &#125;, section &quot;__DATA, __objc_const&quot;, align 8  </span><br><span class="line">@&quot;\01l_OBJC_METACLASS_RO_$_foo&quot; = private global %struct._class_ro_t &#123; i32 1, i32 40, i32 40, i8* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @OBJC_CLASS_NAME_, i32 0, i32 0), %struct.__method_list_t* bitcast (&#123; i32, i32, [1 x %struct._objc_method] &#125;* @&quot;\01l_OBJC_$_CLASS_METHODS_foo&quot; to %struct.__method_list_t*), %struct._objc_protocol_list* null, %struct._ivar_list_t* null, i8* null, %struct._prop_list_t* null &#125;, section &quot;__DATA, __objc_const&quot;, align 8  </span><br><span class="line">@&quot;OBJC_METACLASS_$_foo&quot; = global %struct._class_t &#123; %struct._class_t* @&quot;OBJC_METACLASS_$_NSObject&quot;, %struct._class_t* @&quot;OBJC_METACLASS_$_NSObject&quot;, %struct._objc_cache* @_objc_empty_cache, i8* (i8*, i8*)** null, %struct._class_ro_t* @&quot;\01l_OBJC_METACLASS_RO_$_foo&quot; &#125;, section &quot;__DATA, __objc_data&quot;, align 8  </span><br><span class="line">@&quot;OBJC_CLASS_$_NSObject&quot; = external global %struct._class_t  </span><br><span class="line">@&quot;\01l_OBJC_CLASS_RO_$_foo&quot; = private global %struct._class_ro_t &#123; i32 0, i32 8, i32 8, i8* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]*   @OBJC_CLASS_NAME_, i32 0, i32 0), %struct.__method_list_t* null, %struct._objc_protocol_list* null, %struct._ivar_list_t* null, i8* null, %struct._prop_list_t* null &#125;, section &quot;__DATA, __objc_const&quot;, align 8  </span><br><span class="line">@&quot;OBJC_CLASS_$_foo&quot; = global %struct._class_t &#123; %struct._class_t* @&quot;OBJC_METACLASS_$_foo&quot;, %struct._class_t* @&quot;OBJC_CLASS_$_NSObject&quot;, %struct._objc_cache* @_objc_empty_cache, i8* (i8*, i8*)** null, %struct._class_ro_t* @&quot;\01l_OBJC_CLASS_RO_$_foo&quot; &#125;, section &quot;__DATA, __objc_data&quot;, align 8  </span><br><span class="line">@&quot;OBJC_LABEL_CLASS_$&quot; = private global [1 x i8*] [i8* bitcast (%struct._class_t* @&quot;OBJC_CLASS_$_foo&quot; to i8*)], section &quot;__DATA,__objc_classlist,regular,no_dead_strip&quot;, align 8  </span><br><span class="line">@llvm.compiler.used = appending global [5 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @OBJC_CLASS_NAME_, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @OBJC_METH_VAR_NAME_, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @OBJC_METH_VAR_TYPE_, i32 0, i32 0), i8* bitcast (&#123; i32, i32, [1 x %struct._objc_method] &#125;* @&quot;\01l_OBJC_$_CLASS_METHODS_foo&quot; to i8*), i8* bitcast ([1 x i8*]* @&quot;OBJC_LABEL_CLASS_$&quot; to i8*)], section &quot;llvm.metadata&quot;</span><br></pre></td></tr></table></figure><p>Note</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@OBJC_CLASS_NAME_ = private unnamed_addr constant [4 x i8] c&quot;foo\00&quot;, section &quot;__TEXT,__objc_classname,cstring_literals&quot;, align 1  </span><br><span class="line">@OBJC_METH_VAR_TYPE_ = private unnamed_addr constant [8 x i8] c&quot;v16@0:8\00&quot;, section &quot;__TEXT,__objc_methtype,cstring_literals&quot;, align 1</span><br></pre></td></tr></table></figure><p>The <code>OBJC_CLASS_NAME_</code> here is also handled by <code>Armariris</code>.In other words, the class is registered in the ObjC Runtime with completely wrong names and types.The result could be catastrophic.<br>Let’s see <a href="https://github.com/opensource-apple/dyld/blob/3f928f32597888c5eac6003b9199d972d49857b5/src/dyld.cpp" target="_blank" rel="noopener">dyld.cpp</a>. Note line 1090:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void initializeMainExecutable()</span><br><span class="line">&#123;</span><br><span class="line">// record that we&apos;ve reached this step</span><br><span class="line">gLinkContext.startedInitializingMainExecutable = true;</span><br><span class="line"></span><br><span class="line">// run initialzers for any inserted dylibs</span><br><span class="line">ImageLoader::InitializerTimingList initializerTimes[sAllImages.size()];</span><br><span class="line">initializerTimes[0].count = 0;</span><br><span class="line">const size_t rootCount = sImageRoots.size();</span><br><span class="line">if ( rootCount &gt; 1 ) &#123;</span><br><span class="line">for(size_t i=1; i &lt; rootCount; ++i) &#123;</span><br><span class="line">sImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[0]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// run initializers for main executable and everything it brings up</span><br><span class="line">sMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[0]);</span><br><span class="line"></span><br><span class="line">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span><br><span class="line">if ( gLibSystemHelpers != NULL )</span><br><span class="line">(*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, NULL, NULL);</span><br><span class="line"></span><br><span class="line">// dump info if requested</span><br><span class="line">if ( sEnv.DYLD_PRINT_STATISTICS )</span><br><span class="line">ImageLoaderMachO::printStatistics((unsigned int)sAllImages.size(), initializerTimes[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>and the following comment right above <code>static void addRootImage(ImageLoader* image)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In order for register_func_for_add_image() callbacks to to be called bottom up,  </span><br><span class="line">we need to maintain a list of root images. The main executable is usally the  </span><br><span class="line">first root. Any images dynamically added are also roots (unless already  loaded).  </span><br><span class="line">If DYLD_INSERT_LIBRARIES is used, those libraries are first.</span><br></pre></td></tr></table></figure><p>In other words, dyld run initializers for libraries first, then the main executable, that means when our binary is starting up, the string constants like ObjC’s class name are still encrypted, which could be troublesome for ObjC and various system libraries.</p><h1 id="Improvements"><a href="#Improvements" class="headerlink" title="Improvements"></a>Improvements</h1><h2 id="Spliting"><a href="#Spliting" class="headerlink" title="Spliting"></a>Spliting</h2><p>The correct implementation would use this to distinguish ObjC strings and C strings:  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;GlobalVariable *&gt; cstrings;</span><br><span class="line">  <span class="built_in">set</span>&lt;GlobalVariable *&gt; objcstrings;</span><br><span class="line">  <span class="comment">// Collect GVs</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> g = M.global_begin(); g != M.global_end(); g++) &#123;</span><br><span class="line">    GlobalVariable *GV = &amp;(*g);</span><br><span class="line">    <span class="comment">// We only handle NonMetadata&amp;&amp;NonObjC&amp;&amp;LocalInitialized&amp;&amp;CDS</span></span><br><span class="line">    <span class="keyword">if</span> (GV-&gt;hasInitializer() &amp;&amp; GV-&gt;isConstant() &amp;&amp;</span><br><span class="line">        GV-&gt;getSection() != StringRef(<span class="string">"llvm.metadata"</span>) &amp;&amp;</span><br><span class="line">        GV-&gt;getSection().find(StringRef(<span class="string">"__objc"</span>)) == <span class="built_in">string</span>::npos &amp;&amp;</span><br><span class="line">        GV-&gt;getName().find(<span class="string">"OBJC"</span>) == <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">      <span class="keyword">if</span> (GV-&gt;hasInitializer() &amp;&amp;</span><br><span class="line">          GV-&gt;getType()-&gt;getElementType() ==</span><br><span class="line">              M.getTypeByName(<span class="string">"struct.__NSConstantString_tag"</span>)) &#123;</span><br><span class="line">        objcstrings.insert(GV);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// isString() asssumes the array has type i8, which should hold on all</span></span><br><span class="line">      <span class="comment">// major platforms  We don't care about some custom os written by 8yo</span></span><br><span class="line">      <span class="comment">// Bob that uses arbitrary ABI</span></span><br><span class="line">      <span class="keyword">if</span> (ConstantDataSequential *CDS =</span><br><span class="line">              dyn_cast&lt;ConstantDataSequential&gt;(GV-&gt;getInitializer())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (CDS-&gt;isString()) &#123;</span><br><span class="line">          cstrings.insert(GV);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// <span class="doctag">FIXME:</span> Correctly Handle ObjC String Constants</span></span><br><span class="line">  <span class="comment">// Probably recreate at runtime and replace pointers?</span></span><br><span class="line">  <span class="keyword">for</span> (GlobalVariable *GV : objcstrings) &#123;</span><br><span class="line">    <span class="comment">//@_unnamed_cfstring_ = private global %struct.__NSConstantString_tag &#123;</span></span><br><span class="line">    <span class="comment">// i32* getelementptr inbounds ([0 x i32], [0 x i32]*</span></span><br><span class="line">    <span class="comment">//@__CFConstantStringClassReference, i32 0, i32 0),  i32 1992, i8*</span></span><br><span class="line">    <span class="comment">// getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i32 0, i32 0), i64 1</span></span><br><span class="line">    <span class="comment">// &#125;,  section "__DATA,__cfstring", align 8</span></span><br><span class="line">    ConstantStruct *CS = dyn_cast&lt;ConstantStruct&gt;(GV-&gt;getInitializer());</span><br><span class="line">    Constant *CE = CS-&gt;getOperand(<span class="number">2</span>); <span class="comment">// This is GEP CE</span></span><br><span class="line">    GlobalVariable *referencedGV =</span><br><span class="line">        dyn_cast&lt;GlobalVariable&gt;(CE-&gt;getOperand(<span class="number">0</span>));</span><br><span class="line">    cstrings.erase(referencedGV);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>which correctly split CFStrings and C-Style strings. This works by collecting all strings first, then iterate all CFStrings and remove the C-Style strings referenced by the CFString from the list</p><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><p>First of all we need to analyze the GV’s def-use chain and locate any instructions referencing it. This is not as trival as it seems because direct users are usually BitCast ConstantExprs, we need to iterate through the def-use chain.<br>Usually the use-def chain we are looking for look like this:<br><code>ConstantExpr-&gt;Instruction-&gt;BasicBlock-&gt;Function</code><br>Then we can either create new AllocaInst at function entrypoint or re-use existing GVs.  The decryption can be done at function entrypoint, then possibly re-encrypt GVs back at terminators. Unless we are dealing with malformed BasicBlocks, which shouldn’t happen unless frontend has gone wild.</p><p>There is a lot to do to make a workable obfuscator and <code>GoSSIP-SJTU</code> surely did some remarkable work, props to them.</p><p>Zhang</p>]]></content:encoded>
      
      <comments>http://mayuyu.io/2017/12/26/StringEncryption/#disqus_thread</comments>
    </item>
    
    <item>
      <title>AntiDebugging Implementation Notes</title>
      <link>http://mayuyu.io/2017/12/21/AntiDebuggingImplementation/</link>
      <guid>http://mayuyu.io/2017/12/21/AntiDebuggingImplementation/</guid>
      <pubDate>Thu, 21 Dec 2017 20:31:17 GMT</pubDate>
      <description>
      
        &lt;p&gt;The current implementation of AntiDebugging is simply inject Inline Assemblies at function start and only works on iOS.&lt;br&gt;Since it’s now possible to do sysent hook on (certain versions of) iOS. Inline &lt;code&gt;ptrace()&lt;/code&gt; alone is no longer safe.&lt;br&gt;Here is a few more ideas to be implemented.&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>The current implementation of AntiDebugging is simply inject Inline Assemblies at function start and only works on iOS.<br>Since it’s now possible to do sysent hook on (certain versions of) iOS. Inline <code>ptrace()</code> alone is no longer safe.<br>Here is a few more ideas to be implemented.<br><a id="more"></a></p><h3 id="Code-Stolen-From-Places"><a href="#Code-Stolen-From-Places" class="headerlink" title="Code Stolen From Places"></a>Code Stolen From Places</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BOOL isDebuggerPresent()&#123;</span><br><span class="line">    int name[4];             </span><br><span class="line"></span><br><span class="line">    struct kinfo_proc info;</span><br><span class="line">    size_t info_size = sizeof(info);</span><br><span class="line"></span><br><span class="line">    info.kp_proc.p_flag = 0;</span><br><span class="line"></span><br><span class="line">    name[0] = CTL_KERN;</span><br><span class="line">    name[1] = KERN_PROC;</span><br><span class="line">    name[2] = KERN_PROC_PID;</span><br><span class="line">    name[3] = getpid();         </span><br><span class="line"></span><br><span class="line">    if(sysctl(name, 4, &amp;info, &amp;info_size, NULL, 0) == -1)&#123;</span><br><span class="line">        NSLog(@&quot;sysctl error ...&quot;);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ((info.kp_proc.p_flag &amp; P_TRACED) != 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGSTOP, 0, dispatch_get_main_queue());</span><br><span class="line">dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">    NSLog(@&quot;SIGSTOP!!!&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(source);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct macosx_exception_info&#123;</span><br><span class="line">    exception_mask_t masks[EXC_TYPES_COUNT];</span><br><span class="line">    mach_port_t ports[EXC_TYPES_COUNT];</span><br><span class="line">    exception_behavior_t behaviors[EXC_TYPES_COUNT];</span><br><span class="line">    thread_state_flavor_t flavors[EXC_TYPES_COUNT];</span><br><span class="line">    mach_msg_type_number_t cout;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct macosx_exception_info *info = malloc(sizeof(struct macosx_exception_info));</span><br><span class="line">task_get_exception_ports(mach_task_self(),</span><br><span class="line">                                            EXC_MASK_ALL,</span><br><span class="line">                                            info-&gt;masks,</span><br><span class="line">                                            &amp;info-&gt;cout,</span><br><span class="line">                                            info-&gt;ports,</span><br><span class="line">                                            info-&gt;behaviors,</span><br><span class="line">                                            info-&gt;flavors);</span><br><span class="line"></span><br><span class="line">for(uint32_t i = 0; i &lt; info-&gt;cout; i ++)&#123;</span><br><span class="line">    if(info-&gt;ports[i] != 0 || info-&gt;flavors[i] == THREAD_STATE_NONE)&#123;</span><br><span class="line">        NSLog(@&quot;debugger detected via exception ports (null port)!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (isatty(1)) &#123;</span><br><span class="line">    NSLog(@&quot;Being Debugged isatty&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!ioctl(1, TIOCGWINSZ)) &#123;</span><br><span class="line">    NSLog(@&quot;Being Debugged ioctl&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ideas-from-jmpews"><a href="#Ideas-from-jmpews" class="headerlink" title="Ideas from @jmpews"></a>Ideas from @jmpews</h3><p>Register Custom EH Pad and intentionally throw exceptions,they should be handled by our very own block.</p>]]></content:encoded>
      
      <comments>http://mayuyu.io/2017/12/21/AntiDebuggingImplementation/#disqus_thread</comments>
    </item>
    
    <item>
      <title>FunctionCallSite/Symbol Obfuscation Implementation Notes</title>
      <link>http://mayuyu.io/2017/12/21/SymbolObfuscationImplementationNotes/</link>
      <guid>http://mayuyu.io/2017/12/21/SymbolObfuscationImplementationNotes/</guid>
      <pubDate>Thu, 21 Dec 2017 20:16:59 GMT</pubDate>
      <description>
      
        &lt;p&gt;By design,Function CallSite Obfuscation aims to replace direct call/invoke instructions with &lt;code&gt;dlsym()&lt;/code&gt; equivalents at IR Level.&lt;br&gt;Symbol Obfuscation also suffers from the exact same issues&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>By design,Function CallSite Obfuscation aims to replace direct call/invoke instructions with <code>dlsym()</code> equivalents at IR Level.<br>Symbol Obfuscation also suffers from the exact same issues<br><a id="more"></a></p><h2 id="Source-of-Symbol"><a href="#Source-of-Symbol" class="headerlink" title="Source of Symbol"></a>Source of Symbol</h2><p>  We can not accurately determine a symbol’s origin at IR Level.For example, the Module might refers to a symbol in a third party library.In which case there is a chance that the symbol is stripped out in Release build and thus crash our compiling process.<br>  A possible approach would be a after-install analysis of system libraries(dyld cache on Darwin/Apple platforms) plus optional arguments at compile time.</p><h2 id="Messed-up-Symbols"><a href="#Messed-up-Symbols" class="headerlink" title="Messed-up Symbols"></a>Messed-up Symbols</h2><p>  Again, on darwin platforms, a bunch of libSystem functions are marked as <code>__DARWIN_ALIAS_C</code> which would screw-up the symbol in various ways.<br>  A possible approach, since these kind of modification has a pattern, would be stripping out prefix/suffixs in our pass.</p><h2 id="Insecure-Implementation-of-system-symbol-searching-mechanism"><a href="#Insecure-Implementation-of-system-symbol-searching-mechanism" class="headerlink" title="Insecure Implementation of system symbol searching mechanism"></a>Insecure Implementation of system symbol searching mechanism</h2><p>  One simple runtime code injection plus some decompiler script is all it takes to defeat our protection.Implementing a custom-baked replacement and mark it as inline instead of using platform implementation would be (kinda) safer.<br>  However this is not possible for ObjC since we can’t ship a custom implemented ObjC Runtime.(Or can we?)</p><p>T.B.C</p>]]></content:encoded>
      
      <comments>http://mayuyu.io/2017/12/21/SymbolObfuscationImplementationNotes/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Anti class-dump Implementation Notes</title>
      <link>http://mayuyu.io/2017/12/21/AntiClassDumpImplementationNotes/</link>
      <guid>http://mayuyu.io/2017/12/21/AntiClassDumpImplementationNotes/</guid>
      <pubDate>Thu, 21 Dec 2017 17:19:36 GMT</pubDate>
      <description>
      
        &lt;p&gt;The core idea of acd is to extract ObjC class informations and create everything at a program-controlled stage instead of letting libObjC do the initialization for us.&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>The core idea of acd is to extract ObjC class informations and create everything at a program-controlled stage instead of letting libObjC do the initialization for us.<br><a id="more"></a></p><h3 id="Dependency-Resolving"><a href="#Dependency-Resolving" class="headerlink" title="Dependency Resolving"></a>Dependency Resolving</h3><p>OOP languages have a core concept called “Classes”, ObjC is no difference.For our transform to work as intended, we need to create classes strictly following the dependency graph.And that means:  </p><ul><li>Classes that don’t have a base class should be created first.</li><li>Following classes that has external dependency, which can be distinguished at IR level by checking if the BaseClass is definition or declaration.This is done using <code>GlobalVariable::hasInitializer ()</code></li><li>Loop through the remaining classes using a deque.Which we repeat the following process until the deque is empty:<ul><li>Pop the front-most class</li><li>Check if this class’s dependency is available<ul><li>If available,process the class</li><li>Otherwise,push the class to the back of the queue</li></ul></li></ul></li></ul><p>The same also applies for protocols. Note we are running our pass at LTO stage to make sure local classes are sorted correctly</p><h2 id="Platform-Dependent-Data-Sizes"><a href="#Platform-Dependent-Data-Sizes" class="headerlink" title="Platform-Dependent Data Sizes"></a>Platform-Dependent Data Sizes</h2><p>Certain ObjC Runtime API uses type like <code>size_t</code> which size is platform dependent.<br>Critical DataStructures like <code>class_ro_t</code> has platform specific definition:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;</span><br><span class="line">    <span class="keyword">method_list_t</span> *baseMethods() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>These issues are resolved by parsing Module’s Triple.</p><h2 id="Handle-IvarLayout"><a href="#Handle-IvarLayout" class="headerlink" title="Handle IvarLayout"></a>Handle IvarLayout</h2><p>  Just add <code>class_setIvarLayout</code> and <code>class_setWeakIvarLayout</code> calls</p><h2 id="Provide-Mode-Switching"><a href="#Provide-Mode-Switching" class="headerlink" title="Provide Mode Switching"></a>Provide Mode Switching</h2><p>  Full LTO is not always possible. As such we should provide three modes:</p><ul><li>Injecting at global initializers</li><li>Replace original metadata_ro_t and leave only <code>+initialize</code>,perform method adding there. Ivars and props are unchanged</li><li>User Custom Initializing using <code>__attribute__((annotate(&quot;FLAGS&quot;)))</code> , which is converted to <code>llvm.global.annotations</code> in <code>llvm.metadata</code></li></ul><h2 id="Fix-ro-flags"><a href="#Fix-ro-flags" class="headerlink" title="Fix ro_flags"></a>Fix ro_flags</h2><p>Google <code>RO_IS_ARR</code>, we need to add instructions to copy flags over after creating class</p><h2 id="Misc-Structs"><a href="#Misc-Structs" class="headerlink" title="Misc Structs"></a>Misc Structs</h2><p><code>CGObjCMac.cpp</code> ‘s comments explained the structs and their meanings in great detail.Below is IR-Level struct and their original definitions</p><p><code>%struct._ivar_t = type { i64*, i8*, i8*, i32, i32 }</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct _ivar_t &#123;</span><br><span class="line">  unsigned [long] int *offset;  // pointer to ivar offset location</span><br><span class="line">  char *name;</span><br><span class="line">  char *type;</span><br><span class="line">  uint32_t alignment;</span><br><span class="line">  uint32_t size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>%struct._ivar_list_t = type { i32, i32, [0 x %struct._ivar_t] }</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct _ivar_list_t &#123;</span><br><span class="line">  uint32 entsize;  // sizeof(struct _ivar_t)</span><br><span class="line">  uint32 count;</span><br><span class="line">  struct _iver_t list[count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">%struct._protocol_t =</span><br><span class="line">type &#123; i8*, i8*,</span><br><span class="line">%struct._objc_protocol_list*,</span><br><span class="line">%struct.__method_list_t*,</span><br><span class="line">%struct.__method_list_t*,</span><br><span class="line">%struct.__method_list_t*,</span><br><span class="line">%struct.__method_list_t*,</span><br><span class="line">%struct._prop_list_t*,</span><br><span class="line">i32, i32, i8**, i8*,</span><br><span class="line">%struct._prop_list_t*</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct _protocol_t &#123;</span><br><span class="line">id isa;  // NULL</span><br><span class="line">const char * const protocol_name;</span><br><span class="line">const struct _protocol_list_t * protocol_list; // super protocols</span><br><span class="line">const struct method_list_t * const instance_methods;</span><br><span class="line">const struct method_list_t * const class_methods;</span><br><span class="line">const struct method_list_t *optionalInstanceMethods;</span><br><span class="line">const struct method_list_t *optionalClassMethods;</span><br><span class="line">const struct _prop_list_t * properties;</span><br><span class="line">const uint32_t size;  // sizeof(struct _protocol_t)</span><br><span class="line">const uint32_t flags;  // = 0</span><br><span class="line">const char ** extendedMethodTypes;</span><br><span class="line">const char *demangledName;</span><br><span class="line">const struct _prop_list_t * class_properties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%struct._objc_protocol_list = type &#123; i64, [0 x %struct._protocol_t*] &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct _protocol_list_t &#123;</span><br><span class="line">long protocol_count;   // Note, this is 32/64 bit</span><br><span class="line">struct _protocol_t[protocol_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%struct._prop_t</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct _prop_t &#123;</span><br><span class="line">char *name;</span><br><span class="line">char *attributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T.B.C</p>]]></content:encoded>
      
      <comments>http://mayuyu.io/2017/12/21/AntiClassDumpImplementationNotes/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Neowiz Protocols</title>
      <link>http://mayuyu.io/2017/11/08/NeowizProtocols/</link>
      <guid>http://mayuyu.io/2017/11/08/NeowizProtocols/</guid>
      <pubDate>Wed, 08 Nov 2017 17:54:55 GMT</pubDate>
      <description>
      
        &lt;p&gt;For all Neowiz games. A similar API protocol is used.&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>For all Neowiz games. A similar API protocol is used.<br><a id="more"></a></p><h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><p>The only variation is the difference between API endpoints. Every request is a HTTP POST request to the API endpoint.The HTTP body is a json serialized string of the request.<br>The header also requires the following fields</p><ul><li>Api-Token : <em>Pass empty string at first.Will be returned by corresponding API later</em></li><li>Fp : <em>The MD5 Hash of (SecretKey+HTTPBody)</em></li><li>Nce : <em>Random 32characters alphanumerical string</em></li><li>Secret-Key : <em>Pass empty string at first.Will be returned by corresponding API later</em></li><li>Secret-Ver : <em>Pass 1 at first.Will be returned by corresponding API later</em></li><li>X-Unity-Version : <em>Game’s version. Hardcoded in the binary</em></li></ul><h2 id="HTTPBody"><a href="#HTTPBody" class="headerlink" title="HTTPBody"></a>HTTPBody</h2><p>Each item in the HTTP body consists of the request’s id ,the method’s name as well as params.<br>For example:<br><code>[{&quot;id&quot;:9,&quot;method&quot;:&quot;user.loginV2&quot;,&quot;params&quot;:[&quot;ACCESS_TOKEN&quot;,&quot; &quot;,&quot;&quot;,&quot;iOS&quot;,&quot;CN&quot;]}]</code><br>contains only one request, which has a id of 9 and name “user.loginV2”.<br>There are 5 parameters in this request, being <code>&quot;ACCESS_TOKEN&quot;,&quot; &quot;,&quot;&quot;,&quot;iOS&quot;,&quot;CN&quot;</code></p><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p>The response is also a json serialized array containing the responses to the request sorted in the same order as the request array.<br>For example:  </p><p><code>[    {        &quot;result&quot;: {            &quot;API_TOKEN&quot;: &quot;API_TOKEN&quot;,            &quot;SECRET_KEY&quot;: &quot;DMQGLBlive7&quot;,            &quot;SECRET_VER&quot;: &quot;1&quot;,            &quot;guid&quot;: &quot;11111&quot;,            &quot;recom_code&quot;: &quot;213SDADd&quot;,            &quot;displayName&quot;: FOO&quot;,            &quot;profileImg&quot;: &quot;http://img.pmangplus.com/members/09332449/profile_img&quot;,            &quot;INTRO_SERVER&quot;: &quot;https://dmqglb.mb.pmang.com/DMQ/rpc&quot;        },        &quot;error&quot;: null,        &quot;id&quot;: 9    }]</code><br>Contains one response, corresponding to the previous request</p><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>The available methods of each game and their arguments can be found by decompiling the game’s Unity DLL or do a HTTP packet capture.</p>]]></content:encoded>
      
      <comments>http://mayuyu.io/2017/11/08/NeowizProtocols/#disqus_thread</comments>
    </item>
    
    <item>
      <title>A Short Analysis of AdAppActive</title>
      <link>http://mayuyu.io/2017/09/22/AdAppActive/</link>
      <guid>http://mayuyu.io/2017/09/22/AdAppActive/</guid>
      <pubDate>Fri, 22 Sep 2017 14:52:54 GMT</pubDate>
      <description>
      
        &lt;p&gt;During my random browsing of PPHelper, China’s largest “assistant” that provids download of cracked softwares as well as serving&lt;br&gt;as a 2nd AppStore itself, we found one of the games contains a strange Adware not seen in its AppStore Version.&lt;/p&gt;
&lt;p&gt;Overall it’s a pretty boring case since the native calls are not obfuscated&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>During my random browsing of PPHelper, China’s largest “assistant” that provids download of cracked softwares as well as serving<br>as a 2nd AppStore itself, we found one of the games contains a strange Adware not seen in its AppStore Version.</p><p>Overall it’s a pretty boring case since the native calls are not obfuscated<br><a id="more"></a><br><a href="AdAppActive.framework/AdAppActive">Sample</a><br>Running <code>codesign -dvvv</code> yields the following information:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Identifier=dujj.com.AdAppActive</span><br><span class="line">Format=bundle with Mach-O universal (armv7 arm64)</span><br><span class="line">CodeDirectory v=20200 size=1424 flags=0x0(none) hashes=64+3 location=embedded</span><br><span class="line">OSPlatform=37</span><br><span class="line">OSSDKVersion=590592</span><br><span class="line">OSVersionMin=458752</span><br><span class="line">Hash type=sha1 size=20</span><br><span class="line">CandidateCDHash sha1=84318837fcc69584ccf6ab194011e707691e8240</span><br><span class="line">Hash choices=sha1</span><br><span class="line">Page size=4096</span><br><span class="line">CDHash=84318837fcc69584ccf6ab194011e707691e8240</span><br><span class="line">Signature size=4378</span><br><span class="line">Authority=iPhone Distribution: Shandong Meibang Information Technology Co., Ltd.</span><br><span class="line">Authority=Apple Worldwide Developer Relations Certification Authority</span><br><span class="line">Authority=Apple Root CA</span><br><span class="line">Signed Time=2017年1月12日 上午2:37:38</span><br><span class="line">Info.plist entries=21</span><br><span class="line">TeamIdentifier=KQE7R93SMR</span><br><span class="line">Sealed Resources version=2 rules=12 files=2</span><br><span class="line">Internal requirements count=1 size=208</span><br></pre></td></tr></table></figure></p><p>Apparently a cracked app will have its CSBlobs removed so now we can be sure that this application has been resigned, which is strange considering this is published on “Applications for Jailbroken Devices”</p><p>Running <code>otool -l</code> against the main binary also yields a new load command:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Load command 57</span><br><span class="line">          cmd LC_LOAD_DYLIB</span><br><span class="line">      cmdsize 80</span><br><span class="line">         name @executable_path/AdAppActive.framework/AdAppActive (offset 24)</span><br><span class="line">   time stamp 2 Thu Jan  1 01:00:02 1970</span><br><span class="line">      current version 1.0.0</span><br><span class="line">compatibility version 1.0.0</span><br></pre></td></tr></table></figure></p><h1 id="The-Binary-Itself"><a href="#The-Binary-Itself" class="headerlink" title="The Binary Itself"></a>The Binary Itself</h1><p>The main functionality of AdAppActive took place in <code>-[PPNiubilitySimpleFactory createClientInfo]</code>, starting from the EntryPoint and in turn calls <code>[TRPPNiubilityManager share]</code></p><p>Inside <code>-[PPNiubilitySimpleFactory createClientInfo]</code>, it calls:  </p><ul><li><code>[PPNiubilityConfiguration sharedConfiguration]</code></li><li><code>[UIDevice isJailBreak]</code></li><li><code>[PPReachability reachabilityForLocalWiFi]</code></li></ul><p>to collect various device information and upload them to <code>http://applog.uc.cn:9081/collect</code></p><h1 id="Dangerous-Behaviours"><a href="#Dangerous-Behaviours" class="headerlink" title="Dangerous Behaviours"></a>Dangerous Behaviours</h1><h2 id="UDID"><a href="#UDID" class="headerlink" title="UDID"></a>UDID</h2><p>  <code>-[PPNiubilitySimpleFactory createClientInfo]</code> calls <code>+[UnitlTool uuid]</code> which in turn abuses <code>MGCopyAnswer</code> in libMobileGestalt to upload the UDID of the device, although theoratically this private API is no longer usable without proper entitlements, and our samples seems to be missing those entitlements, it only contains:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">        &lt;key&gt;application-identifier&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;K5X9BM5TQ2.com.yinhan.SpaceHunterPP.IPad-260064-6&lt;/string&gt;</span><br><span class="line">        &lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;K5X9BM5TQ2&lt;/string&gt;</span><br><span class="line">        &lt;key&gt;get-task-allow&lt;/key&gt;</span><br><span class="line">        &lt;false/&gt;</span><br><span class="line">        &lt;key&gt;keychain-access-groups&lt;/key&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">                &lt;string&gt;K5X9BM5TQ2.com.yinhan.SpaceHunterPP.IPad-260064-6&lt;/string&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure></p><p><img src="MG.png" alt=""></p><h2 id="IOKit"><a href="#IOKit" class="headerlink" title="IOKit"></a>IOKit</h2><p>  Various methods in the class <code>UIDeviceAdditions</code> seems to be abusing IOKit and sysctl to fetch ECID/SerialNumber/MAC Address/Platform.<br>  This is also no longer usable in sandbox since around iOS 9.3.X<br><img src="IOKit.png" alt=""></p><h2 id="Various-Thoughts"><a href="#Various-Thoughts" class="headerlink" title="Various Thoughts"></a>Various Thoughts</h2><p>  Judging by:</p><ul><li>The history of this kind of “assistants” and their commercial mode</li><li>The sample is marking its <code>promotion channel/APP ID</code> to the server</li><li>The original developer hasn’t started a lawsuit yet</li><li>I’ve also examined another 12 games on PPHelper and none of them contains AdAppActive</li><li><p>IPAs of this exact game found elsewhere doesn’t contain AdAppActive as well</p><p>I think it’s safe to assume the developer is involved in this mess. I’ve already emailed the developer regarding this</p></li></ul><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li>Dynamic binary instrumention</li><li>Report this to AAPL’s product security team to invalidate KQE7R93SMR</li></ul>]]></content:encoded>
      
      <comments>http://mayuyu.io/2017/09/22/AdAppActive/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Exploring LLVM ExecutionEngine</title>
      <link>http://mayuyu.io/2017/07/12/Exploring-LLVM-ExecutionEngine/</link>
      <guid>http://mayuyu.io/2017/07/12/Exploring-LLVM-ExecutionEngine/</guid>
      <pubDate>Wed, 12 Jul 2017 21:44:13 GMT</pubDate>
      <description>
      
        &lt;p&gt;  So recently I was researching a method regarding a better binary protection technique on iOS. Ideally VMProtect-like.&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>  So recently I was researching a method regarding a better binary protection technique on iOS. Ideally VMProtect-like.<br>  <a id="more"></a></p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Years ago I had the same thought, at that time <a href="http://llvm.org/docs/CommandGuide/lli.html" target="_blank" rel="noopener">lli</a> was still very naive and has pretty limited support regarding platforms. However recently after seeing a dozen of Chinese “Mobile Application Security” companies claiming they can now run their clients’ code in a “VM”<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Yes because security is completely based on obscurity /s">[1]</span></a></sup>, I was thinking “How would I implement such a thing?” and “How is that possible?” because as we all know iOS has kernel policies in place to ensure JIT is not possible <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Detailed explanation is not my area and you should be able to find plenty of slides using a search engine">[2]</span></a></sup> so the implementation has to be interpretering.</p><p>I honestly doubt that those companies will design a completely new IR/BitCode format instead of using the LLVM-Style IR which is already part of the day to day build process and is currently <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="In my humble opinion, that is">[3]</span></a></sup> <strong>de facto</strong> industry standard. Now this whole theory reminds me <code>lli</code>. Now the <strong>LLVM JIT</strong> is being described as:</p><blockquote><p>currently supports X86,<br> X86-64,ARM, AArch64, Mips, SystemZ, PowerPC, and PowerPC-64.</p></blockquote><p>Searching <code>Interpreter</code> lands us at <code>llvm/ExecutionEngine/Interpreter.h</code>, which is a subclass of <code>ExecutionEngine</code><br><code>ExecutionEngine</code> has a constructor that takes a <code>std::unique_ptr&lt;Module&gt;</code> as an argument. If you’ve ever messed around with LLVM or read my previous beginner’s explanations, you would surely know that each TranslationUnit is represented using a <code>Module</code>, and Modules can be linked at the IR Level to form a bigger Module. For anyone missed it, here is the official description:</p><blockquote><p>A Module instance is used to store all the information related to an LLVM module.<br>Modules are the top level container of all other LLVM Intermediate Representation (IR) objects. Each module directly contains a list of globals variables, a list of functions, a list of libraries (or other modules) this module depends on, a symbol table, and various data about the target’s characteristics.<br>A module maintains a GlobalValRefMap object that is used to hold all constant references to global variables in the module. When a global variable is destroyed, it should have no entries in the GlobalValueRefMap. The main container class for the LLVM Intermediate Representation.</p></blockquote><p>Now our tasks seem to be clear:</p><ul><li>Compile whatever code we want to run into LLVM IR</li><li>In our interpreter, deserialize IR and create Module-&gt;Create Execution Engine-&gt;Run</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p><code>clang -fobjc-arc -S -emit-llvm Input.c -o Input.ll</code></p><p>Our test code is:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static int add(int a,int b)&#123;</span><br><span class="line">  return a+b;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">  printf(&quot;Hello From The LLVMEESide:\n15+20 is:%i\n&quot;,add(15,20));</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And the interpreter goes as:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.cpp</span><br><span class="line">//  LLVMJit</span><br><span class="line">//</span><br><span class="line">//  Created by Naville Zhang on 2017/7/12.</span><br><span class="line">//  Copyright © 2017 NavilleZhang. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;llvm/ExecutionEngine/ExecutionEngine.h&gt;</span><br><span class="line">#include &lt;llvm/ExecutionEngine/Interpreter.h&gt;//Otherwise LTO will mess up our binary</span><br><span class="line">#include &lt;llvm/IR/Module.h&gt;</span><br><span class="line">#include &lt;llvm/IRReader/IRReader.h&gt;</span><br><span class="line">#include &lt;llvm/IR/LLVMContext.h&gt;</span><br><span class="line">#include &lt;llvm/Support/SourceMgr.h&gt;</span><br><span class="line">#include &lt;llvm/Support/TargetSelect.h&gt;</span><br><span class="line">#include &lt;llvm/ExecutionEngine/GenericValue.h&gt;</span><br><span class="line">#include &lt;llvm-c/Core.h&gt;</span><br><span class="line">using namespace llvm;</span><br><span class="line">using namespace std;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    InitializeNativeTarget();</span><br><span class="line">    SMDiagnostic SMD;</span><br><span class="line">    LLVMContext context;</span><br><span class="line">    std::string err;</span><br><span class="line">    EngineBuilder EB(parseIRFile(&quot;/PATH/TO/COMPILED/LL&quot;,SMD,context));</span><br><span class="line">    EB.setEngineKind(EngineKind::Interpreter);</span><br><span class="line">    EB.setErrorStr(&amp;err);</span><br><span class="line">    ExecutionEngine* EE=EB.create();</span><br><span class="line">    EE-&gt;runStaticConstructorsDestructors(false);</span><br><span class="line">    Function* main=EE-&gt;FindFunctionNamed(&quot;main&quot;);</span><br><span class="line">    EE-&gt;runFunction(main,ArrayRef&lt;GenericValue&gt;());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Of course you also have to add library&header search path, mess around with linker settings. I personally linked all of them">[4]</span></a></sup></p><p>It failed miserably, logging out errors regarding failed external function calling, searching <code>external function</code> in <a href="http://llvm.org/docs/CMake.html" target="_blank" rel="noopener">http://llvm.org/docs/CMake.html</a> brought us to</p><blockquote><p>LLVM_ENABLE_FFI:BOOL<br>Indicates whether the LLVM Interpreter will be linked with the Foreign Function Interface library (libffi) in order to enable calling external functions. If the library or its headers are installed in a custom location, you can also set the variables FFI_INCLUDE_DIR and FFI_LIBRARY_DIR to the directories where ffi.h and libffi.so can be found, respectively. Defaults to OFF.</p></blockquote><p>Compile LLVM again with<code>-DLLVM_ENABLE_FFI=on</code>and link to libFFI in your interpreter.Yikes<br>  <img src="Success.png" alt=""><sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Yes I messed up the description string">[5]</span></a></sup></p><h1 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h1><p>It would be boring if it’s that easy to implement a interpreter. There are quite some limitations:</p><ul><li>Varadic external function is not supported. <code>printf</code> in the aforementioned example is actually implemented by the Interpreter itself.We need to modify interpreter’s <code>callFunction</code> to pass remaining data types all the way down to <a href="https://github.com/llvm-mirror/llvm/blob/master/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp" target="_blank" rel="noopener">lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp</a> ‘s <code>ffiInvoke</code> to add missing argument types</li><li>Structs are currently unsupported by <code>ExecutionEngine</code> itself.</li><li>A large amount of system libraries, most notably <code>libOBJC</code> has initialize routines that requires various native level stuff. Like <code>libOBJC</code> initialize runtime classes/SELs/etc by scanning special sections in the binary<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="We can:  <del>Implement our own libOBJC and ship it with the IR</del> Won't work due to native libraries not initialized in IR  Write LLVM Pass to leave native ObjC Runtime structs intact,throw original implementation into IR and replace with native briging function">[6]</span></a></sup></li><li>Performance impact would be huge</li><li>GVs need to be mapped to native in order to be usable for native calls</li></ul><h1 id="Improvements"><a href="#Improvements" class="headerlink" title="Improvements"></a>Improvements</h1><ul><li>Use our existing IR-Obfuscation techniques to make the IR unreadable even if the attacker managed to dump the IR</li><li>Obfuscate the interpreter itself</li><li>Compile to BitCode and mess around with the IntrinsicID table (or whatever it’s called) to make sure the attacker can not <code>llvm-dis</code> our BitCode even if he/she managed to dump it.</li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Yes because security is completely based on obscurity /s<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Detailed explanation is not my area and you should be able to find plenty of slides using a search engine<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">In my humble opinion, that is<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Of course you also have to add library&amp;header search path, mess around with linker settings. I personally linked all of them<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Yes I messed up the description string<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">We can:<br><del>Implement our own libOBJC and ship it with the IR</del> Won’t work due to native libraries not initialized in IR<br>Write LLVM Pass to leave native ObjC Runtime structs intact,throw original implementation into IR and replace with native briging function<a href="#fnref:6" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>http://mayuyu.io/2017/07/12/Exploring-LLVM-ExecutionEngine/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hooking MGCopyAnswer Like A Boss</title>
      <link>http://mayuyu.io/2017/06/26/HookingMGCopyAnswerLikeABoss/</link>
      <guid>http://mayuyu.io/2017/06/26/HookingMGCopyAnswerLikeABoss/</guid>
      <pubDate>Mon, 26 Jun 2017 13:36:33 GMT</pubDate>
      <description>
      
        &lt;p&gt;  This is a note following &lt;a href=&quot;/2017/04/05/Random-Thoughts-On-Hooking-Short-Functions/&quot;&gt;my post&lt;/a&gt; back in april regarding short function hooking.&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>  This is a note following <a href="/2017/04/05/Random-Thoughts-On-Hooking-Short-Functions/">my post</a> back in april regarding short function hooking.<br>  <a id="more"></a></p><p>  In the aforementioned post we talked about <em>Analyzing assembly</em> and its usage scenario.<br>  Here in China the advertisement/analytics SDK developers abuses various private iOS APIs to uniquely identify a device.<br>  And hackers bypass these checks to fake data in order to squeeze every single penny of investors.<br>  (Actually it’s much more than that but this is not our main topic)</p><p>  One of the most abused API is <code>MGCopyAnswer</code> in libMobileGestalt, but directly hooking it will instantly crash the process with an <code>invalid instruction</code>.<br>  However if you’ve ever analyzed the library in disassemblers you would notice that this function is actually using another private symbol-less routine to perform its tasks and this routine is always the first branching instruction in <code>MGCopyAnswer</code>.</p><p>  <img src="Hopper.png" alt=""></p><p>  As such, a pretty obvious method would be hooking this subroutine, as mentioned in my previous post.But how do you know the address if it doesn’t have a symbol to begin with? Relative offset? Possible, but maybe not stable.<br>  Fortunately, we have <a href="http://www.capstone-engine.org" target="_blank" rel="noopener">Capstone Engine</a>, which is a powerful disassembler based on LLVM’s MC to save the day.<br>  Now we have the “signature”(First B in MGCopyAnswer),and a disassembler. All we need is to disassemble <code>MGCopyAnswer</code> and locate the subroutine for hooking. A sample PoC code can be found at <a href="https://github.com/Naville/MobileGestaltHooking/" target="_blank" rel="noopener">https://github.com/Naville/MobileGestaltHooking/</a><br>  <img src="Log.png" alt=""><br>  <img src="Log2.png" alt=""></p><h1 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h1><p>  Apparently this PoC code is not using any architecture detection and it currently works in AArch64 only.<br>  You might want to add a few marco definition checks in production environment and adjust <code>cs_open</code>‘s arguments accordingly</p><p>  @Ouroboros mentioned that <code>insn[j].id == ARM64_INS_BL</code> might be a better solution than <code>strcmp()</code></p>]]></content:encoded>
      
      <comments>http://mayuyu.io/2017/06/26/HookingMGCopyAnswerLikeABoss/#disqus_thread</comments>
    </item>
    
    <item>
      <title>LLVM Hacking-0x2 Manipulating GlobalVariable and Obfuscate ObjC Control Flow</title>
      <link>http://mayuyu.io/2017/06/02/LLVMHacking-0x2/</link>
      <guid>http://mayuyu.io/2017/06/02/LLVMHacking-0x2/</guid>
      <pubDate>Fri, 02 Jun 2017 07:34:18 GMT</pubDate>
      <description>
      
        &lt;p&gt;  This is part of my planned LLVM-Hacking blog posts, intended for new compiler hobbists like myself&lt;br&gt;  &lt;del&gt;PoC codes are available at &lt;a href=&quot;https://github.com/Naville/LLVM-Hacking-Tut-Source&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Naville/LLVM-Hacking-Tut-Source&lt;/a&gt;&lt;/del&gt;.&lt;br&gt;  The sample codes have been removed due to inaccuracy and stuff. A more robust Obfuscator implementation is open-source at &lt;a href=&quot;https://github.com/HikariObfuscator/Hikari&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HikariObfuscator/Hikari&lt;/a&gt;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>  This is part of my planned LLVM-Hacking blog posts, intended for new compiler hobbists like myself<br>  <del>PoC codes are available at <a href="https://github.com/Naville/LLVM-Hacking-Tut-Source" target="_blank" rel="noopener">https://github.com/Naville/LLVM-Hacking-Tut-Source</a></del>.<br>  The sample codes have been removed due to inaccuracy and stuff. A more robust Obfuscator implementation is open-source at <a href="https://github.com/HikariObfuscator/Hikari" target="_blank" rel="noopener">HikariObfuscator/Hikari</a><br>  <a id="more"></a></p><p>In our second chapter I’m gonna demostrate some basic usage of <code>GlobalVariable</code> and using these techniques to build a pass that will obfuscate ObjC control flow.</p><p>In order to achieve this, we’d like to hide <code>SEL</code> and <code>Class</code> references. First let’s compile some sample ObjC codes into LLVM IR to have a general idea about what happened under the hood.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  [[NSMutableData <span class="keyword">new</span>] increaseLengthBy:<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>generates the following LLVM IR:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">target datalayout = &quot;e-m:o-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple = &quot;x86_64-apple-macosx10.12.0&quot;</span><br><span class="line"></span><br><span class="line">%0 = type opaque</span><br><span class="line">%struct._class_t = type &#123; %struct._class_t*, %struct._class_t*, %struct._objc_cache*, i8* (i8*, i8*)**, %struct._class_ro_t* &#125;</span><br><span class="line">%struct._objc_cache = type opaque</span><br><span class="line">%struct._class_ro_t = type &#123; i32, i32, i32, i8*, i8*, %struct.__method_list_t*, %struct._objc_protocol_list*, %struct._ivar_list_t*, i8*, %struct._prop_list_t* &#125;</span><br><span class="line">%struct.__method_list_t = type &#123; i32, i32, [0 x %struct._objc_method] &#125;</span><br><span class="line">%struct._objc_method = type &#123; i8*, i8*, i8* &#125;</span><br><span class="line">%struct._objc_protocol_list = type &#123; i64, [0 x %struct._protocol_t*] &#125;</span><br><span class="line">%struct._protocol_t = type &#123; i8*, i8*, %struct._objc_protocol_list*, %struct.__method_list_t*, %struct.__method_list_t*, %struct.__method_list_t*, %struct.__method_list_t*, %struct._prop_list_t*, i32, i32, i8**, i8*, %struct._prop_list_t* &#125;</span><br><span class="line">%struct._ivar_list_t = type &#123; i32, i32, [0 x %struct._ivar_t] &#125;</span><br><span class="line">%struct._ivar_t = type &#123; i64*, i8*, i8*, i32, i32 &#125;</span><br><span class="line">%struct._prop_list_t = type &#123; i32, i32, [0 x %struct._prop_t] &#125;</span><br><span class="line">%struct._prop_t = type &#123; i8*, i8* &#125;</span><br><span class="line"></span><br><span class="line">@&quot;OBJC_CLASS_$_NSMutableData&quot; = external global %struct._class_t</span><br><span class="line">@&quot;OBJC_CLASSLIST_REFERENCES_$_&quot; = private global %struct._class_t* @&quot;OBJC_CLASS_$_NSMutableData&quot;, section &quot;__DATA, __objc_classrefs, regular, no_dead_strip&quot;, align 8</span><br><span class="line">@OBJC_METH_VAR_NAME_ = private global [4 x i8] c&quot;new\00&quot;, section &quot;__TEXT,__objc_methname,cstring_literals&quot;, align 1</span><br><span class="line">@OBJC_SELECTOR_REFERENCES_ = private externally_initialized global i8* getelementptr inbounds ([4 x i8], [4 x i8]* @OBJC_METH_VAR_NAME_, i32 0, i32 0), section &quot;__DATA, __objc_selrefs, literal_pointers, no_dead_strip&quot;, align 8</span><br><span class="line">@OBJC_METH_VAR_NAME_.1 = private global [18 x i8] c&quot;increaseLengthBy:\00&quot;, section &quot;__TEXT,__objc_methname,cstring_literals&quot;, align 1</span><br><span class="line">@OBJC_SELECTOR_REFERENCES_.2 = private externally_initialized global i8* getelementptr inbounds ([18 x i8], [18 x i8]* @OBJC_METH_VAR_NAME_.1, i32 0, i32 0), section &quot;__DATA, __objc_selrefs, literal_pointers, no_dead_strip&quot;, align 8</span><br><span class="line">@llvm.compiler.used = appending global [5 x i8*] [i8* bitcast (%struct._class_t** @&quot;OBJC_CLASSLIST_REFERENCES_$_&quot; to i8*), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @OBJC_METH_VAR_NAME_, i32 0, i32 0), i8* bitcast (i8** @OBJC_SELECTOR_REFERENCES_ to i8*), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @OBJC_METH_VAR_NAME_.1, i32 0, i32 0), i8* bitcast (i8** @OBJC_SELECTOR_REFERENCES_.2 to i8*)], section &quot;llvm.metadata&quot;</span><br><span class="line"></span><br><span class="line">; Function Attrs: norecurse ssp uwtable</span><br><span class="line">define i32 @main() #0 &#123;</span><br><span class="line">  %1 = alloca i32, align 4</span><br><span class="line">  store i32 0, i32* %1, align 4</span><br><span class="line">  %2 = load %struct._class_t*, %struct._class_t** @&quot;OBJC_CLASSLIST_REFERENCES_$_&quot;, align 8</span><br><span class="line">  %3 = load i8*, i8** @OBJC_SELECTOR_REFERENCES_, align 8, !invariant.load !7</span><br><span class="line">  %4 = bitcast %struct._class_t* %2 to i8*</span><br><span class="line">  %5 = call i8* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to i8* (i8*, i8*)*)(i8* %4, i8* %3)</span><br><span class="line">  %6 = bitcast i8* %5 to %0*</span><br><span class="line">  %7 = load i8*, i8** @OBJC_SELECTOR_REFERENCES_.2, align 8, !invariant.load !7</span><br><span class="line">  %8 = bitcast %0* %6 to i8*</span><br><span class="line">  call void bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to void (i8*, i8*, i64)*)(i8* %8, i8* %7, i64 20)</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: nonlazybind</span><br><span class="line">declare i8* @objc_msgSend(i8*, i8*, ...) #1</span><br><span class="line"></span><br><span class="line">attributes #0 = &#123; norecurse ssp uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;=&quot;false&quot; &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-jump-tables&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;penryn&quot; &quot;target-features&quot;=&quot;+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;</span><br><span class="line">attributes #1 = &#123; nonlazybind &#125;</span><br><span class="line"></span><br><span class="line">!llvm.module.flags = !&#123;!0, !1, !2, !3, !4, !5&#125;</span><br><span class="line">!llvm.ident = !&#123;!6&#125;</span><br><span class="line"></span><br><span class="line">!0 = !&#123;i32 1, !&quot;Objective-C Version&quot;, i32 2&#125;</span><br><span class="line">!1 = !&#123;i32 1, !&quot;Objective-C Image Info Version&quot;, i32 0&#125;</span><br><span class="line">!2 = !&#123;i32 1, !&quot;Objective-C Image Info Section&quot;, !&quot;__DATA, __objc_imageinfo, regular, no_dead_strip&quot;&#125;</span><br><span class="line">!3 = !&#123;i32 4, !&quot;Objective-C Garbage Collection&quot;, i32 0&#125;</span><br><span class="line">!4 = !&#123;i32 1, !&quot;Objective-C Class Properties&quot;, i32 64&#125;</span><br><span class="line">!5 = !&#123;i32 1, !&quot;PIC Level&quot;, i32 2&#125;</span><br><span class="line">!6 = !&#123;!&quot;Apple LLVM version 8.1.0 (clang-802.0.42)&quot;&#125;</span><br><span class="line">!7 = !&#123;&#125;</span><br></pre></td></tr></table></figure><p>Note the two <code>LoadInst</code> referencing <code>OBJC_CLASSLIST_REFERENCES_</code> and <code>OBJC_SELECTOR_REFERENCES_</code>.<br>Now let’s walk away from LLVM Core for a while and focus on the frontend,<code>Clang</code>, you can find a unofficial web-friendly mirror here:<br><a href="https://github.com/llvm-mirror/clang/blob/b0c092f298d809acb814934c0ef593104d633713/lib/CodeGen/CGObjCMac.cpp" target="_blank" rel="noopener">https://github.com/llvm-mirror/clang/blob/b0c092f298d809acb814934c0ef593104d633713/lib/CodeGen/CGObjCMac.cpp</a></p><p>Search for <code>OBJC_CLASSLIST_REFERENCES</code> brings us to Line 7125, which shows GV <code>OBJC_CLASSLIST_REFERENCES</code> is constructed as:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Entry = <span class="keyword">new</span> llvm::GlobalVariable(CGM.getModule(), ObjCTypes.ClassnfABIPtrTy,</span><br><span class="line">                                     <span class="literal">false</span>, llvm::GlobalValue::PrivateLinkage,</span><br><span class="line">                                     ClassGV, <span class="string">"OBJC_CLASSLIST_REFERENCES_$_"</span>);</span><br></pre></td></tr></table></figure><p>which corresponds to the following <code>GlobalVariable</code> constructor:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GlobalVariable (Module &amp;M, Type *Ty, <span class="keyword">bool</span> isConstant, LinkageTypes Linkage,</span><br><span class="line">Constant *Initializer, <span class="keyword">const</span> Twine &amp;Name=<span class="string">""</span>, GlobalVariable   *InsertBefore=<span class="literal">nullptr</span>,</span><br><span class="line">ThreadLocalMode=NotThreadLocal, <span class="keyword">unsigned</span> AddressSpace=<span class="number">0</span>,   <span class="keyword">bool</span> isExternallyInitialized=<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>Now we can write a simple LLVM Pass:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...OMITTED...</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> G=M.getGlobalList().begin();G!=M.getGlobalList().end();G++)&#123;</span><br><span class="line">        GlobalVariable &amp;GV=*G;</span><br><span class="line">errs()&lt;&lt;GV.getName()&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">...OMITTED...</span><br></pre></td></tr></table></figure><p>prints out:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">llvm.compiler.used</span><br><span class="line">OBJC_CLASSLIST_REFERENCES_$_  </span><br><span class="line">OBJC_METH_VAR_NAME_</span><br><span class="line">OBJC_SELECTOR_REFERENCES_</span><br><span class="line">OBJC_METH_VAR_NAME_.1</span><br><span class="line">OBJC_SELECTOR_REFERENCES_.2</span><br><span class="line">OBJC_CLASS_$_NSMutableData</span><br><span class="line">OBJC_METACLASS_$_Utils</span><br><span class="line">OBJC_METACLASS_$_NSObject</span><br><span class="line">_objc_empty_cache</span><br><span class="line">l_OBJC_METACLASS_RO_$_Utils</span><br><span class="line">OBJC_CLASS_NAME_</span><br><span class="line">l_OBJC_$_CLASS_METHODS_Utils</span><br><span class="line">OBJC_METH_VAR_NAME_.2</span><br><span class="line">OBJC_METH_VAR_TYPE_</span><br><span class="line">_unnamed_cfstring_</span><br><span class="line">__CFConstantStringClassReference</span><br><span class="line">.str</span><br><span class="line">OBJC_CLASS_$_Utils</span><br><span class="line">OBJC_CLASS_$_NSObject</span><br><span class="line">l_OBJC_CLASS_RO_$_Utils</span><br><span class="line">OBJC_LABEL_CLASS_$</span><br></pre></td></tr></table></figure><p>Now we can improve our sample pass a little bit to collect <code>OBJC_CLASSLIST_REFERENCES_</code> ‘s initializers:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...OMITTED...</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> G=M.getGlobalList().begin();G!=M.getGlobalList().end();G++)&#123;</span><br><span class="line">        GlobalVariable &amp;GV=*G;</span><br><span class="line"><span class="keyword">if</span> (GV.getName().str().find(<span class="string">"OBJC_CLASSLIST_REFERENCES"</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">string</span> className=GV.getInitializer ()-&gt;getName();</span><br><span class="line">          errs()&lt;&lt;className&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...OMITTED...</span><br></pre></td></tr></table></figure><p>yielding <code>OBJC_CLASS_$_NSMutableData</code> , strip out the prefix<code>className.replace(className.find(&quot;OBJC_CLASS_$_&quot;),strlen(&quot;OBJC_CLASS_$_&quot;),&quot;&quot;);</code> and we now have the Class Name:<code>NSMutableData</code></p><p>At last, we want to find all IRs referencing to our <code>GV</code> and replace them with a <code>objc_getClass()</code> call.<br>We can first obtain the original Instruction, through GV iteration,construct the Function,using IRBuilder to build CallInst and finally replace uses</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> G=M.global_begin(); G!=M.global_end(); G++) &#123;</span><br><span class="line">        GlobalVariable &amp;GV=*G;</span><br><span class="line">        <span class="keyword">if</span> (GV.getName().str().find(<span class="string">"OBJC_CLASSLIST_REFERENCES"</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(GV.hasInitializer()) &#123;</span><br><span class="line">                        <span class="built_in">string</span> className=GV.getInitializer ()-&gt;getName();</span><br><span class="line">                        className.replace(className.find(<span class="string">"OBJC_CLASS_$_"</span>),<span class="built_in">strlen</span>(<span class="string">"OBJC_CLASS_$_"</span>),<span class="string">""</span>);</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">auto</span> U=GV.user_begin (); U!=GV.user_end(); U++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (Instruction* I = dyn_cast&lt;Instruction&gt;(*U)) &#123;</span><br><span class="line">                                        IRBuilder&lt;&gt; builder(I);</span><br><span class="line">                                        FunctionType *objc_getClass_type =FunctionType::get(I-&gt;getType(), &#123;Type::getInt8PtrTy(M.getContext())&#125;, <span class="literal">false</span>);</span><br><span class="line">                                        Function *objc_getClass_Func = cast&lt;Function&gt;(M.getOrInsertFunction(<span class="string">"objc_getClass"</span>, objc_getClass_type ) );</span><br><span class="line">                                        Value* newClassName=builder.CreateGlobalStringPtr(StringRef(className));</span><br><span class="line">                                        CallInst* CI=builder.CreateCall(objc_getClass_Func,&#123;newClassName&#125;);</span><br><span class="line">                                        I-&gt;replaceAllUsesWith(CI);</span><br><span class="line">                                        I-&gt;eraseFromParent ();</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://mayuyu.io/2017/06/02/LLVMHacking-0x2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>LLVM Hacking-0x1 Symbol Renaming</title>
      <link>http://mayuyu.io/2017/06/01/LLVMHacking-0x1/</link>
      <guid>http://mayuyu.io/2017/06/01/LLVMHacking-0x1/</guid>
      <pubDate>Thu, 01 Jun 2017 20:18:27 GMT</pubDate>
      <description>
      
        &lt;p&gt;  This is part of my planned LLVM-Hacking blog posts, intended for new compiler hobbists like myself&lt;br&gt;  &lt;del&gt;PoC codes are available at &lt;a href=&quot;https://github.com/Naville/LLVM-Hacking-Tut-Source&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Naville/LLVM-Hacking-Tut-Source&lt;/a&gt;&lt;/del&gt;.&lt;br&gt;  The sample codes have been removed due to inaccuracy and stuff. A more robust Obfuscator implementation is open-source at &lt;a href=&quot;https://github.com/HikariObfuscator/Hikari&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HikariObfuscator/Hikari&lt;/a&gt;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>  This is part of my planned LLVM-Hacking blog posts, intended for new compiler hobbists like myself<br>  <del>PoC codes are available at <a href="https://github.com/Naville/LLVM-Hacking-Tut-Source" target="_blank" rel="noopener">https://github.com/Naville/LLVM-Hacking-Tut-Source</a></del>.<br>  The sample codes have been removed due to inaccuracy and stuff. A more robust Obfuscator implementation is open-source at <a href="https://github.com/HikariObfuscator/Hikari" target="_blank" rel="noopener">HikariObfuscator/Hikari</a><br>  <a id="more"></a><br>  To start from the easy ones, our first task is to rename function symbols to serve as a better obfuscator,to replace existing pre-processing based obfuscations.</p><p>  The core idea is pretty simple, we just create something inherits one of the pass classes and override the <code>runOnXXX</code> methods.<br>  Since functions (and the majority,if not all) LLVM IR components inherits from <code>llvm::Value</code>, we can use <code>llvm::Value::getName()</code> and <code>llvm::Value::setName()</code> for function name manipulating.</p><p>  Since LLVM Passes <em>DO NOT</em> preserve states between TU(Translation Unit)s, it becomes pretty obvious that we can obtain a one and only global TU Module by injecting our pass at LTO stage. If you have no idea about LTO, please refer to <a href="http://llvm.org/docs/LinkTimeOptimization.html" target="_blank" rel="noopener">http://llvm.org/docs/LinkTimeOptimization.html</a></p><h2 id="How-to-register-LTO-Pass"><a href="#How-to-register-LTO-Pass" class="headerlink" title="How to register LTO Pass"></a>How to register LTO Pass</h2><p>You need to modify <code>llvm/Transforms/IPO/PassManagerBuild.cpp</code> and add your pass in <code>populateLTOPassManager</code><br>Also add your transform module to <code>llvm/Transforms/IPO/LLVMBuild.txt</code></p><h2 id="The-pass-itself"><a href="#The-pass-itself" class="headerlink" title="The pass itself"></a>The pass itself</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  LLVM SymbolObfuscation Pass</span></span><br><span class="line"><span class="comment"> *  Zhang@University of Glasgow</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Instructions.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Pass.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Module.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Support/raw_ostream.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Transforms/IPO/PassManagerBuilder.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/LegacyPassManager.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Transforms/Obfuscation/SymbolObfuscation.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">string</span> obfcharacters=<span class="string">"qwertyuiopasdfghjklzxcvbnm1234567890"</span>;</span><br><span class="line"><span class="keyword">namespace</span> llvm&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SymbolObfuscation</span> :</span> <span class="keyword">public</span> ModulePass &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line">    SymbolObfuscation() : ModulePass(ID) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">randomString</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">      <span class="built_in">string</span> name;</span><br><span class="line">      name.resize(length);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        name[i]=obfcharacters[rand()%(obfcharacters.length()+<span class="number">1</span>)];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">runOnModule</span><span class="params">(Module &amp;M)</span> override </span>&#123;</span><br><span class="line">      <span class="comment">//F.setName(randomString(16));</span></span><br><span class="line">      errs()&lt;&lt;<span class="string">"Do not go gentle into that good night\n"</span>;</span><br><span class="line">      <span class="comment">//Remember each Module has an iterator of Functions</span></span><br><span class="line">      <span class="comment">//Each Function has an iterator of BasicBlocks</span></span><br><span class="line">      <span class="comment">//Each BB has an iterator of instructions</span></span><br><span class="line">      <span class="keyword">for</span>(Module::iterator Fun=M.begin();Fun!=M.end();Fun++)&#123;</span><br><span class="line">        Function &amp;F=*Fun;</span><br><span class="line">        <span class="comment">//Rename</span></span><br><span class="line">        errs()&lt;&lt;<span class="string">"Renaming Function: "</span>&lt;&lt;F.getName()&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">        F.setName(randomString(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function">Pass * <span class="title">createSymbolObf</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> SymbolObfuscation();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> SymbolObfuscation::ID = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>Compile, it works, however external function calls are also messed up,so does <code>main</code> , so we add required checks and now our <code>runOnModule</code> looks like this:</p><p>Note that F.empty() is underlying checking if the function has any BasicBlock, an external function apparently don’t. Thus we can skip renaming.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">runOnModule</span><span class="params">(Module &amp;M)</span> override </span>&#123;</span><br><span class="line">  <span class="comment">//F.setName(randomString(16));</span></span><br><span class="line">  errs()&lt;&lt;<span class="string">"Do not go gentle into that good night\n"</span>;</span><br><span class="line">  <span class="keyword">for</span>(Module::iterator Fun=M.begin();Fun!=M.end();Fun++)&#123;</span><br><span class="line">    Function &amp;F=*Fun;</span><br><span class="line">    <span class="keyword">if</span> (F.getName().str().compare(<span class="string">"main"</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">      errs()&lt;&lt;<span class="string">"Skipping main\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(F.empty()==<span class="literal">false</span>)&#123;</span><br><span class="line">      <span class="comment">//Rename</span></span><br><span class="line">      errs()&lt;&lt;<span class="string">"Renaming Function: "</span>&lt;&lt;F.getName()&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">      F.setName(randomString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      errs()&lt;&lt;<span class="string">"Skipping External Function: "</span>&lt;&lt;F.getName()&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now it works fine on our test code <code>test.mm</code>. Yielding the following LLVM IR for our test case</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">source_filename = &quot;test.mm&quot;</span><br><span class="line">target datalayout = &quot;e-m:o-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple = &quot;x86_64-apple-macosx10.12.0&quot;</span><br><span class="line"></span><br><span class="line">%0 = type opaque</span><br><span class="line">%struct.__NSConstantString_tag = type &#123; i32*, i32, i8*, i64 &#125;</span><br><span class="line">%struct._objc_cache = type opaque</span><br><span class="line">%struct._class_t = type &#123; %struct._class_t*, %struct._class_t*, %struct._objc_cache*, i8* (i8*, i8*)**, %struct._class_ro_t* &#125;</span><br><span class="line">%struct._class_ro_t = type &#123; i32, i32, i32, i8*, i8*, %struct.__method_list_t*, %struct._objc_protocol_list*, %struct._ivar_list_t*, i8*, %struct._prop_list_t* &#125;</span><br><span class="line">%struct.__method_list_t = type &#123; i32, i32, [0 x %struct._objc_method] &#125;</span><br><span class="line">%struct._objc_method = type &#123; i8*, i8*, i8* &#125;</span><br><span class="line">%struct._objc_protocol_list = type &#123; i64, [0 x %struct._protocol_t*] &#125;</span><br><span class="line">%struct._protocol_t = type &#123; i8*, i8*, %struct._objc_protocol_list*, %struct.__method_list_t*, %struct.__method_list_t*, %struct.__method_list_t*, %struct.__method_list_t*, %struct._prop_list_t*, i32, i32, i8**, i8*, %struct._prop_list_t* &#125;</span><br><span class="line">%struct._ivar_list_t = type &#123; i32, i32, [0 x %struct._ivar_t] &#125;</span><br><span class="line">%struct._ivar_t = type &#123; i64*, i8*, i8*, i32, i32 &#125;</span><br><span class="line">%struct._prop_list_t = type &#123; i32, i32, [0 x %struct._prop_t] &#125;</span><br><span class="line">%struct._prop_t = type &#123; i8*, i8* &#125;</span><br><span class="line"></span><br><span class="line">@__CFConstantStringClassReference = external global [0 x i32]</span><br><span class="line">@.str = private unnamed_addr constant [4 x i8] c&quot;foo\00&quot;, section &quot;__TEXT,__cstring,cstring_literals&quot;, align 1</span><br><span class="line">@_unnamed_cfstring_ = private global %struct.__NSConstantString_tag &#123; i32* getelementptr inbounds ([0 x i32], [0 x i32]* @__CFConstantStringClassReference, i32 0, i32 0), i32 1992, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i64 3 &#125;, section &quot;__DATA,__cfstring&quot;, align 8</span><br><span class="line">@_objc_empty_cache = external global %struct._objc_cache</span><br><span class="line">@&quot;OBJC_METACLASS_$_NSObject&quot; = external global %struct._class_t</span><br><span class="line">@OBJC_CLASS_NAME_ = private unnamed_addr constant [6 x i8] c&quot;Utils\00&quot;, section &quot;__TEXT,__objc_classname,cstring_literals&quot;, align 1</span><br><span class="line">@OBJC_METH_VAR_NAME_ = private unnamed_addr constant [4 x i8] c&quot;foo\00&quot;, section &quot;__TEXT,__objc_methname,cstring_literals&quot;, align 1</span><br><span class="line">@OBJC_METH_VAR_TYPE_ = private unnamed_addr constant [8 x i8] c&quot;v16@0:8\00&quot;, section &quot;__TEXT,__objc_methtype,cstring_literals&quot;, align 1</span><br><span class="line">@&quot;\01l_OBJC_$_CLASS_METHODS_Utils&quot; = private global &#123; i32, i32, [1 x %struct._objc_method] &#125; &#123; i32 24, i32 1, [1 x %struct._objc_method] [%struct._objc_method &#123; i8* getelementptr inbounds ([4 x i8], [4 x i8]* @OBJC_METH_VAR_NAME_, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @OBJC_METH_VAR_TYPE_, i32 0, i32 0), i8* bitcast (void (i8*, i8*)* @&quot;pig7\003urf5gjv1cj&quot; to i8*) &#125;] &#125;, section &quot;__DATA, __objc_const&quot;, align 8</span><br><span class="line">@&quot;\01l_OBJC_METACLASS_RO_$_Utils&quot; = private global %struct._class_ro_t &#123; i32 1, i32 40, i32 40, i8* null, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @OBJC_CLASS_NAME_, i32 0, i32 0), %struct.__method_list_t* bitcast (&#123; i32, i32, [1 x %struct._objc_method] &#125;* @&quot;\01l_OBJC_$_CLASS_METHODS_Utils&quot; to %struct.__method_list_t*), %struct._objc_protocol_list* null, %struct._ivar_list_t* null, i8* null, %struct._prop_list_t* null &#125;, section &quot;__DATA, __objc_const&quot;, align 8</span><br><span class="line">@&quot;OBJC_METACLASS_$_Utils&quot; = global %struct._class_t &#123; %struct._class_t* @&quot;OBJC_METACLASS_$_NSObject&quot;, %struct._class_t* @&quot;OBJC_METACLASS_$_NSObject&quot;, %struct._objc_cache* @_objc_empty_cache, i8* (i8*, i8*)** null, %struct._class_ro_t* @&quot;\01l_OBJC_METACLASS_RO_$_Utils&quot; &#125;, section &quot;__DATA, __objc_data&quot;, align 8</span><br><span class="line">@&quot;OBJC_CLASS_$_NSObject&quot; = external global %struct._class_t</span><br><span class="line">@&quot;\01l_OBJC_CLASS_RO_$_Utils&quot; = private global %struct._class_ro_t &#123; i32 0, i32 8, i32 8, i8* null, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @OBJC_CLASS_NAME_, i32 0, i32 0), %struct.__method_list_t* null, %struct._objc_protocol_list* null, %struct._ivar_list_t* null, i8* null, %struct._prop_list_t* null &#125;, section &quot;__DATA, __objc_const&quot;, align 8</span><br><span class="line">@&quot;OBJC_CLASS_$_Utils&quot; = global %struct._class_t &#123; %struct._class_t* @&quot;OBJC_METACLASS_$_Utils&quot;, %struct._class_t* @&quot;OBJC_CLASS_$_NSObject&quot;, %struct._objc_cache* @_objc_empty_cache, i8* (i8*, i8*)** null, %struct._class_ro_t* @&quot;\01l_OBJC_CLASS_RO_$_Utils&quot; &#125;, section &quot;__DATA, __objc_data&quot;, align 8</span><br><span class="line">@&quot;OBJC_CLASSLIST_REFERENCES_$_&quot; = private global %struct._class_t* @&quot;OBJC_CLASS_$_Utils&quot;, section &quot;__DATA, __objc_classrefs, regular, no_dead_strip&quot;, align 8</span><br><span class="line">@OBJC_SELECTOR_REFERENCES_ = private externally_initialized global i8* getelementptr inbounds ([4 x i8], [4 x i8]* @OBJC_METH_VAR_NAME_, i32 0, i32 0), section &quot;__DATA, __objc_selrefs, literal_pointers, no_dead_strip&quot;, align 8</span><br><span class="line">@.str.1 = private unnamed_addr constant [4 x i8] c&quot;CXX\00&quot;, section &quot;__TEXT,__cstring,cstring_literals&quot;, align 1</span><br><span class="line">@_unnamed_cfstring_.2 = private global %struct.__NSConstantString_tag &#123; i32* getelementptr inbounds ([0 x i32], [0 x i32]* @__CFConstantStringClassReference, i32 0, i32 0), i32 1992, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0), i64 3 &#125;, section &quot;__DATA,__cfstring&quot;, align 8</span><br><span class="line">@&quot;OBJC_LABEL_CLASS_$&quot; = private global [1 x i8*] [i8* bitcast (%struct._class_t* @&quot;OBJC_CLASS_$_Utils&quot; to i8*)], section &quot;__DATA, __objc_classlist, regular, no_dead_strip&quot;, align 8</span><br><span class="line">@llvm.compiler.used = appending global [7 x i8*] [i8* getelementptr inbounds ([6 x i8], [6 x i8]* @OBJC_CLASS_NAME_, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @OBJC_METH_VAR_NAME_, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @OBJC_METH_VAR_TYPE_, i32 0, i32 0), i8* bitcast (&#123; i32, i32, [1 x %struct._objc_method] &#125;* @&quot;\01l_OBJC_$_CLASS_METHODS_Utils&quot; to i8*), i8* bitcast (%struct._class_t** @&quot;OBJC_CLASSLIST_REFERENCES_$_&quot; to i8*), i8* bitcast (i8** @OBJC_SELECTOR_REFERENCES_ to i8*), i8* bitcast ([1 x i8*]* @&quot;OBJC_LABEL_CLASS_$&quot; to i8*)], section &quot;llvm.metadata&quot;</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline optnone ssp uwtable</span><br><span class="line">define internal void @&quot;pig7\003urf5gjv1cj&quot;(i8*, i8*) #0 &#123;</span><br><span class="line">  %3 = alloca i8*, align 8</span><br><span class="line">  %4 = alloca i8*, align 8</span><br><span class="line">  store i8* %0, i8** %3, align 8</span><br><span class="line">  store i8* %1, i8** %4, align 8</span><br><span class="line">  notail call void (%0*, ...) @NSLog(%0* bitcast (%struct.__NSConstantString_tag* @_unnamed_cfstring_ to %0*))</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare void @NSLog(%0*, ...) #1</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline norecurse optnone ssp uwtable</span><br><span class="line">define i32 @main() #2 &#123;</span><br><span class="line">  %1 = alloca i32, align 4</span><br><span class="line">  store i32 0, i32* %1, align 4</span><br><span class="line">  %2 = load %struct._class_t*, %struct._class_t** @&quot;OBJC_CLASSLIST_REFERENCES_$_&quot;, align 8</span><br><span class="line">  %3 = load i8*, i8** @OBJC_SELECTOR_REFERENCES_, align 8, !invariant.load !8</span><br><span class="line">  %4 = bitcast %struct._class_t* %2 to i8*</span><br><span class="line">  call void bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to void (i8*, i8*)*)(i8* %4, i8* %3)</span><br><span class="line">  call void @hluet9h72idwmo2f()</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: nonlazybind</span><br><span class="line">declare i8* @objc_msgSend(i8*, i8*, ...) #3</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline optnone ssp uwtable</span><br><span class="line">define linkonce_odr void @hluet9h72idwmo2f() #0 align 2 &#123;</span><br><span class="line">  notail call void (%0*, ...) @NSLog(%0* bitcast (%struct.__NSConstantString_tag* @_unnamed_cfstring_.2 to %0*))</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">attributes #0 = &#123; noinline optnone ssp uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;=&quot;false&quot; &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-jump-tables&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;=&quot;false&quot; &quot;no-trapping-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;penryn&quot; &quot;target-features&quot;=&quot;+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;</span><br><span class="line">attributes #1 = &#123; &quot;correctly-rounded-divide-sqrt-fp-math&quot;=&quot;false&quot; &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;=&quot;false&quot; &quot;no-trapping-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;penryn&quot; &quot;target-features&quot;=&quot;+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;</span><br><span class="line">attributes #2 = &#123; noinline norecurse optnone ssp uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;=&quot;false&quot; &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-jump-tables&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;=&quot;false&quot; &quot;no-trapping-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;penryn&quot; &quot;target-features&quot;=&quot;+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;</span><br><span class="line">attributes #3 = &#123; nonlazybind &#125;</span><br><span class="line"></span><br><span class="line">!llvm.module.flags = !&#123;!0, !1, !2, !3, !4, !5, !6&#125;</span><br><span class="line">!llvm.ident = !&#123;!7&#125;</span><br><span class="line"></span><br><span class="line">!0 = !&#123;i32 1, !&quot;Objective-C Version&quot;, i32 2&#125;</span><br><span class="line">!1 = !&#123;i32 1, !&quot;Objective-C Image Info Version&quot;, i32 0&#125;</span><br><span class="line">!2 = !&#123;i32 1, !&quot;Objective-C Image Info Section&quot;, !&quot;__DATA, __objc_imageinfo, regular, no_dead_strip&quot;&#125;</span><br><span class="line">!3 = !&#123;i32 4, !&quot;Objective-C Garbage Collection&quot;, i32 0&#125;</span><br><span class="line">!4 = !&#123;i32 1, !&quot;Objective-C Class Properties&quot;, i32 64&#125;</span><br><span class="line">!5 = !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125;</span><br><span class="line">!6 = !&#123;i32 7, !&quot;PIC Level&quot;, i32 2&#125;</span><br><span class="line">!7 = !&#123;!&quot;clang version 5.0.0 (trunk 304373)&quot;&#125;</span><br><span class="line">!8 = !&#123;&#125;</span><br></pre></td></tr></table></figure><p>That being said, Objective-C class information can still be retrieved by parsing Objective-C Structures, the solution to that problem involves some other more advanced IR manipulating and will be discussed in the next post</p><p>Until next time.</p><p><strong>UPDATE:</strong></p><p>  Example has been update with ObjC ClassName/MethodName obfuscating codes.<br>  The key is to obtain <code>OBJC_METH_VAR_NAME_</code> and <code>OBJC_CLASS_NAME_</code> referenced by a bunch of other ObjC runtime structs and <code>replaceAllUsesWith</code><br>  Note that this code <strong>DOES NOT</strong> separate external and local class/selectors because there is no way to directly do those.<br>  A reasonable approach would be parse and extract those info from unobfuscated symbols.</p><p><strong>UPDATE2:</strong><br>  Or, simply GV iterate through <code>l_OBJC_$_CLASS_METHODS_CLASSNAME</code> and parse/replace the structs,which contains pointer to string names, one could theoretically create new method/classname string Constants and replace those structs, which is guaranteed <em>NOT</em> to have the <code>SEL</code> / <code>ClassName</code> collision overhead</p>]]></content:encoded>
      
      <comments>http://mayuyu.io/2017/06/01/LLVMHacking-0x1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Building LLVM Doc(set)</title>
      <link>http://mayuyu.io/2017/04/06/BuildingLLVMDoc/</link>
      <guid>http://mayuyu.io/2017/04/06/BuildingLLVMDoc/</guid>
      <pubDate>Thu, 06 Apr 2017 20:18:27 GMT</pubDate>
      <description>
      
        &lt;p&gt;  LLVM has a large doc base which takes literally 12hours+ to build on my configuration.&lt;br&gt;  This post is a collection of techniques I found that could improve either the build doc size/build time/quality&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>  LLVM has a large doc base which takes literally 12hours+ to build on my configuration.<br>  This post is a collection of techniques I found that could improve either the build doc size/build time/quality<br><a id="more"></a></p><h1 id="Generic-Changes"><a href="#Generic-Changes" class="headerlink" title="Generic Changes"></a>Generic Changes</h1><ul><li>Change <code>VERBATIM_HEADERS</code> and <code>SOURCE_BROWSER</code> to <code>NO</code>. This would remove embedded LLVM source, results in much smaller build size and shorter build time.</li><li>Change <code>STRIP_FROM_PATH</code> to correct file-system folder base, this would fix some issues where absolute path is included in the product</li></ul><h1 id="Speedup-Indexing"><a href="#Speedup-Indexing" class="headerlink" title="Speedup Indexing"></a>Speedup Indexing</h1><p>After generating the docs, you can generate  Apple Docset, in which the indexing process would take more than 12hours normally.<br>  Edit the generated Makefile</p><pre><code>- Clang:``$(BUILD_ROOT)/tools/clang/docs/doxygen/html/Makefile``  - LLVM: ``$(BUILD_ROOT)/docs/doxygen/html/Makefile``  </code></pre><p>  Change <code>$(XCODE_INSTALL)/usr/bin/docsetutil index $(DOCSET_NAME)</code> to<br>  <code>$(XCODE_INSTALL)/usr/bin/docsetutil index -skip-text $(DOCSET_NAME)</code> will decrease the indexing time to roughly an hour or so without negative impact as far as I know</p><h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><ul><li>Change <code>CREATE_SUBDIRS</code> to <code>YES</code><br>  This option is described as:        </li></ul><blockquote><p>If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 4096 sub-directories (in 2 levels) under the output directory of each output format and will distribute the generated files over these directories. Enabling this<br>option can be useful when feeding doxygen a huge amount of source files, where putting all generated files in the same directory would otherwise causes performance problems for the file system.  </p></blockquote><ul><li>Edit <code>DOCSET_FEEDNAME</code>,<br><code>DOCSET_BUNDLE_ID</code>,<code>DOCSET_PUBLISHER_ID</code>,<br><code>DOCSET_PUBLISHER_NAME</code> if <code>GENERATE_DOCSET</code> is set to <code>YES</code> (Used for building Apple Docset</li><li>Change <code>DOT_IMAGE_FORMAT</code> to <code>svg</code> and <code>INTERACTIVE_SVG</code> to <code>YES</code>, the former would use SVGs instead of PNGs, the latter would generate interactive,zoom-able inherit diagrams</li></ul><ul><li>For Apple Docset users, refer to <a href="https://kapeli.com/docsets#doxygen" target="_blank" rel="noopener">https://kapeli.com/docsets#doxygen</a> for more specific instructions</li></ul>]]></content:encoded>
      
      <comments>http://mayuyu.io/2017/04/06/BuildingLLVMDoc/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Random Thoughts On Hooking Short Functions</title>
      <link>http://mayuyu.io/2017/04/04/Random-Thoughts-On-Hooking-Short-Functions/</link>
      <guid>http://mayuyu.io/2017/04/04/Random-Thoughts-On-Hooking-Short-Functions/</guid>
      <pubDate>Tue, 04 Apr 2017 18:10:17 GMT</pubDate>
      <description>
      
        &lt;p&gt;  For languages that doesn’t have a reflection mechanism that benefits developers (and hackers), (I’m looking at you Objective-C) function hooking inevitably involves in inline hooking, or to be more precise, assembly patching. Unfortunately not every C function has enough length for us to do our dirty work.&lt;br&gt;  This post is my $0.02 regarding this issue. Theoretically following analysis should hold true on most platforms, although the implementation might differ&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>  For languages that doesn’t have a reflection mechanism that benefits developers (and hackers), (I’m looking at you Objective-C) function hooking inevitably involves in inline hooking, or to be more precise, assembly patching. Unfortunately not every C function has enough length for us to do our dirty work.<br>  This post is my $0.02 regarding this issue. Theoretically following analysis should hold true on most platforms, although the implementation might differ</p><a id="more"></a><h3 id="Hook-Patch-ing-Lazy-Symbol-table"><a href="#Hook-Patch-ing-Lazy-Symbol-table" class="headerlink" title="Hook(Patch)ing Lazy Symbol table"></a>Hook(Patch)ing Lazy Symbol table</h3><p>  This is the simplest solution, by replacing LazySymbol pointers using tools like fishhook.</p><ul><li><code>+</code> Easy to use.</li><li><code>+</code> Not restricted by target function length.</li><li><code>+</code> Not intrusive. Thus won’t trigger security mechanisms</li><li><code>-</code> Only works to lazy symbols linked at runtime. Won’t work for dynamically resolved symbols using functions like dlsym() or direct function call from the same binary/library</li><li><code>-</code> Requires thorough parsing of executable. Hard to implement</li></ul><h3 id="Patching-dlsym"><a href="#Patching-dlsym" class="headerlink" title="Patching dlsym()"></a>Patching dlsym()</h3><p>  Not much worth mentioning. On iOS this is a  decent replacement for certain functions that is too short to patch and usually resolved at runtime. (<strong>COUGH COUGH</strong>)</p><h3 id="Analyzing-assembly"><a href="#Analyzing-assembly" class="headerlink" title="Analyzing assembly"></a>Analyzing assembly</h3><p>  Most functions that are too short to use inline hook are barely a wrapper around some other functions that carries out the actual task. By analyzing assembly from function prologue and search for <strong>JUMP</strong> instructions we can locate the inner function that is likely long enough for inline hook. Note that this process can be automated using open-source disassembling frameworks like <a href="http://www.capstone-engine.org/" target="_blank" rel="noopener">capstone-engine</a></p><ul><li><code>+</code> (Probably the only solution that)Works for short functions</li><li><code>-</code> Relies on the function matches the characteristics described above, there are quite some functions don’t match those. (We will describe below)</li><li><code>-</code> The binary/library/whatever container will have to contain a huge disassembling library</li><li><code>-</code> False-Positives from “effort-less” disassembling, or requires too much effort if the function is analyzed by a human</li></ul><h3 id="Patching-The-Kernel"><a href="#Patching-The-Kernel" class="headerlink" title="Patching The Kernel"></a>Patching The Kernel</h3><p>  There is a bunch of C function in libC that are barebone wrappers around syscalls. For (<strong>RARE</strong>) situations like this (and LazySymbol Patching Does’t Work), the only feasible solution would be patching the sysent table in the kernel</p><ul><li><code>+</code> Accurate function hooking, as all other high-level wrappers are still using syscalls under-the-hood</li><li><code>?</code> Can intercept corresponding call in all processes</li><li><code>-</code> SUPER Hard to implement.</li><li><code>-</code> Requires Kernel Access.</li><li><code>-</code> Affects system performance.</li><li><code>-</code> (Probably) unstable</li></ul><h3 id="Patch-Calling-Instructions-Purely-Theoretical"><a href="#Patch-Calling-Instructions-Purely-Theoretical" class="headerlink" title="Patch Calling Instructions(Purely Theoretical)"></a>Patch Calling Instructions(Purely Theoretical)</h3><p>  Well there are unfortunate scenarios that none of the above is feasible. The last possibility would be searching Calling Instructions to our target and modify those instructions to jump to our proxy function.</p><ul><li><code>+</code> For certain usage scenarios this can be statically applied and thus won’t trigger various protection mechanism.</li><li><code>+</code> You probably don’t have a choice</li><li><code>-</code> Requires full binary analyzing &amp;&amp; disassembling &amp;&amp; patching. Nightmare</li><li><code>-</code> For each new __TEXT loaded, this process has to be repeated. <em>HUGE</em> performance impact</li></ul>]]></content:encoded>
      
      <comments>http://mayuyu.io/2017/04/04/Random-Thoughts-On-Hooking-Short-Functions/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Implementing A Custom MachO Parser</title>
      <link>http://mayuyu.io/2017/03/09/Writing-A-Custom-MachO-Parser/</link>
      <guid>http://mayuyu.io/2017/03/09/Writing-A-Custom-MachO-Parser/</guid>
      <pubDate>Thu, 09 Mar 2017 07:04:41 GMT</pubDate>
      <description>
      
        &lt;p&gt;  Despite Mach-O being a (somewhat) popular executable format. Current open-source implementations lacks either  cross-platform support or some obscure LoadCommand types. Furthermore, there is no library (not that I know of) supports deserialize and &lt;strong&gt;re&lt;/strong&gt;serialize of MachO executables, which would have been a useful tool for Reverse Engineers&lt;/p&gt;
&lt;p&gt;  Thus a personal research project &lt;a href=&quot;https://github.com/Naville/NyachOKit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NyachOKit&lt;/a&gt; was initialized in an attempt to solve this issues once and for all.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note: This article is more like a technical note for implementing my own parser.&lt;/strong&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>  Despite Mach-O being a (somewhat) popular executable format. Current open-source implementations lacks either  cross-platform support or some obscure LoadCommand types. Furthermore, there is no library (not that I know of) supports deserialize and <strong>re</strong>serialize of MachO executables, which would have been a useful tool for Reverse Engineers</p><p>  Thus a personal research project <a href="https://github.com/Naville/NyachOKit" target="_blank" rel="noopener">NyachOKit</a> was initialized in an attempt to solve this issues once and for all.</p><p><strong>Note: This article is more like a technical note for implementing my own parser.</strong></p><a id="more"></a><h1 id="Design-Principles"><a href="#Design-Principles" class="headerlink" title="Design Principles"></a>Design Principles</h1><p>The main difficulties of building a library capable of solving the issues proposed above, in my humble opinion , is the over-complexed internal dependencies of a MachO Executable. As such, one of the design principles is to <strong>strip away redundant information as much as possible and reconstruct them on-the-fly during re-construction</strong>.</p><p>Another issue of MachO parsing is endian conversions. As such each ADT contains a flag for the endians.</p><h1 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h1><p>Theoretically a tree might be a better ADT than the current implementation (a list of objects) , however since we’ve stripped away redundant information and linked raw data to their corresponding load commands, the tree is effectively a unsorted tree, thus current ADT design is suitable (in my humble opinion) and the time-consuming and overkill tree design can be abandoned</p><h2 id="implementation-Specifications"><a href="#implementation-Specifications" class="headerlink" title="implementation Specifications"></a>implementation Specifications</h2><p>Everything is mapped into a corresponding C++ Object. The core is a thin MachO Parser. Fat Mach-Os are mapped into an object containing fat headers and a list of thin Mach-O objects.</p><p>Thin MachO parser is iterable object so malformed MachOs will only stop parsing at a point (Useful for fixing malformed ones), insteading of crashing the whole analyzing process.</p><p>Each Load Command is mapped into a corresponding LC Object.</p><h3 id="LoadCommand-Classes"><a href="#LoadCommand-Classes" class="headerlink" title="LoadCommand Classes"></a>LoadCommand Classes</h3><ul><li>The usual header fields (mapped into a hashmap with field name being the struct field name) as well as a pointer to data (If this LC type contains associated data) or NULL.</li><li>Method for serializing data to specified file offsets</li><li><p>String description</p><p>Note the HashMap design is for better frontend GUIs</p></li></ul>]]></content:encoded>
      
      <comments>http://mayuyu.io/2017/03/09/Writing-A-Custom-MachO-Parser/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
